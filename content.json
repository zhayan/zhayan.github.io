{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"常用知识、技能备忘","text":"SCP 命令参考菜鸟教程. Linux scp 命令用于 Linux 之间复制文件和目录。scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。 常用命令： local2remote.sh12scp local_file remote_username@remote_ip:remote_folder #-P 端口号 -r 整个目录 Python 字符串切割一般用法 12string.split(str, num)#str -- 分隔符 num -- 分割次数 结果为list 对使用不等数量空格分隔符 123string = \"a b c d\"string.split()#['a', 'b', 'c', 'd'] 对使用多种分隔符 12345import restring =\"Beautiful, is; better*than\\nugly\"# 四个分隔符为：, ; * \\nre.split(',|; |\\*|\\n',string)#['Beautiful', ' is', 'better', 'than', 'ugly'] 从后往前分割 123string = \"/home/username/text.txt\"string.rsplit('/',1)#['/home/username', 'text.txt'] sklearn classifier输出置信度1clf.predict_proba(sample) Linux 处理大量文件(xargs)更多参考xargs 命令教程(阮一峰) 用于rm cp 等命令参数过多无法执行 用于多线程同时执行 12345ls | xargs rm #'|'表示将前面命令的输出作为后面命令的输入#对于需要文件夹名称的情况echo dir/* | xarg python a.py # -n {几个分隔的参数做一次命令} -P {最大进程数}#echo 不会因为*参数过多","link":"/2020/04/11/%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E3%80%81%E6%8A%80%E8%83%BD%E5%A4%87%E5%BF%98/"},{"title":"面试书籍资料索引","text":"主要技能LinuxLinux工具快速教程 linux-insides 《Linux内核设计与实现》 读书笔记 C++Linux C/C++编程一站式学习 《C++ primer》 笔记和练习题 安全技术数据挖掘","link":"/2021/01/28/%E9%9D%A2%E8%AF%95%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/"},{"title":"知识总结--数据结构","text":"","link":"/2020/12/22/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"知识总结--C++","text":"参考书籍《C++ primer》《effective C++》《STL源码解析》《深度搜索C++对象模型》 语法相关extern关键字extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。 作用 与”C”一起连用时，如: extern “C” void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的”脾气”了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊。 ，当extern不与”C”在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。 STL相关定义C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件： 组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 vector（向量）STL中标准而安全的数组。 deque（双端队列 double-ended queue）在功能上和vector相似，但是可以在前后两端向其中添加数据。 list（列表）游标一次只可以移动一步。STL中的list则是一个双向链表（每个节点有指向前驱和指向后继的两个指针）。 set（集合）包含了经过排序了的数据，这些数据的值(value)必须是唯一的。 multiset（多重集）和集合（set）相似，然而其中的值不要求必须是唯一的（即可以有重复）。 map（映射）经过排序了的二元组的集合，map中的每个元素都是由两个值组成，其中的key（键值，一个map中的键值必须是唯一的）是在排序或搜索时使用，它的值可以在容器中重新获取；而另一个值是该元素关联的数值。 multimap（多重映射）和映射（map）相似，然而其中的键值不要求必须是唯一的（即可以有重复）。 C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树(Red-Black Tree)。RB树的统计性能要好于一般的平衡二叉树(有些书籍根据作者姓名，Adelson-Velskii和Landis，将其称为AVL-树)，所以被STL选择作为了关联容器的内部结构。","link":"/2020/12/22/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-C/"},{"title":"知识总结-Linux","text":"记录Linux学习中相对重要的点和常用知识、技能参考了Linux Tool Quick Tutorial Linux基础及常用命令帮助型命令whatis简要说明命令的作用参数 -w 正则匹配 info更加详细的命令说明，（测试无法使用） man查询命令的说明文档九个类别 which查看程序的路径 whereis查看命令多个可能的位置（多个版本等） 文件管理命令创建和删除 创建：mkdir 删除：rm (删除非空目录 -rf) 移动：mv 复制：cp (复制目录：cp -r ) 目录切换 找到文件/目录位置：cd 切换到上一个工作目录： cd - 切换到home目录： cd or cd ~ 显示当前路径: pwd 更改当前工作路径为path: $cd path 列出目录项 显示当前目录下的文件 ls 按时间排序，以列表的方式显示目录项 ls -lrt 给每项文件前面增加一个id编号(看上去更加整洁) ls | cat -n 按页查看 more 查找目录及文件 实时查找 find 更快的查询 locate，locate会为文件系统建立索引数据库，如果有文件更新，需要定期执行更新命令 updatedb 来更新索引库 查看文件内容 查看文件: cat vi head tail more 显示时同时显示行号: cat -n 按页显示列表内容: ls -al | more 显示文件第一行: head -1 filename 显示文件倒数第五行: tail -5 filename 查看两个文件间的差别: diff file1 file2 动态显示文本最新信息: tail -f crawler.log 查找文件内容egrep查询文件内容: egrep ‘03.1/CO/AE’ TSF_STAT_111130.log.012 egrep ‘A_LMCA777:C’ TSF_STAT_111130.log.035 &gt; co.out2 文件与目录权限修改 改变文件的拥有者 chown 改变文件读、写、执行等属性 chmod 递归子目录修改： chown -R tuxapp source/ 增加脚本可执行权限： chmod a+x myscript 命令间 批处理命令连接执行，使用 | 串联: 使用分号 ; 前面成功，则执行后面一条，否则，不执行:&amp;&amp; 前面失败，则后一条执行: || todo Shell 输入/输出重定向 文本处理find 文件查找 查找txt和pdf文件: find . ( -name “.txt” -o -name “.pdf” ) -print 否定参数 !,查找所有非txt文本: find . ! -name “*.txt” -print 指定搜索深度-maxdepth,同时有depth,打印出当前目录的文件（深度为1）: find . -maxdepth 1 -type f 按类型搜索: -type f 文件 / l 符号链接 / d 目录 按时间搜索 atime 访问时间 (单位是天，分钟单位则是-amin，以下类似） mtime 修改时间 （内容被修改） ctime 变化时间 （元数据或权限变化） 找到后的后续动作 参数-delete删除 执行动作,参数-exec -print使用‘\\n’作为文件定界符，-print0使用‘\\0’作为定界符，用于搜索包含空格的文件 grep 文本搜索1grep match_patten file // 默认访问匹配行 -o 只输出匹配的文本行 VS -v 只输出没有匹配的文本行 -c 统计文件中包含文本的次数 -n 打印匹配的行号 -i 搜索时忽略大小写 -l 只打印文件名 在多级目录中对文本递归搜索(程序员搜代码的最爱）: grep “class” . -R -n 匹配多个模式: grep -e “class” -e “vitural” file grep输出以0作为结尾符的文件名（-z）: grep “test” file* -lZ| xargs -0 rm xargs 命令行参数转换 -d 定义定界符 （默认为空格 多行的定界符为 n） -n 指定输出为多行 -I {} 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时 -0：指定0为输入定界符 -P 10 十线程执行 更多参考xargs 命令教程(阮一峰) sort 排序 -n 按数字进行排序 VS -d 按字典序进行排序 -r 逆序排序 -k N 指定按第N列排序 忽略像空格之类的前导空白字符: sort -bd data uniq 消除重复行默认消除重复行 -c 统计各行在文件中出现的次数 -d 找出重复行 -s 开始位置 -w 比较字符数 tr 进行转换字符12echo 12345 | tr '0-9' '9876543210' //加解密转换，替换对应字符cat text| tr '\\t' ' ' //制表符转空格 -d 删除字符 -c 使用给定字符串的补集 -s 压缩文本中出现的重复字符；最常用于压缩多余的空格 tr中可用各种字符类： alnum：字母和数字 alpha：字母 digit：数字 space：空白字符 lower：小写 upper：大写 cntrl：控制（非可打印）字符 print：可打印字符 1tr '[:lower:]' '[:upper:]' cut 按列切分文本 截取文件的第2列和第4列 cut -f2,4 filename 去文件除第3列的所有列 cut -f3 –complement filename -d 指定定界符 cat -f2 -d”;” filename cut 取的范围 N- 第N个字段到结尾 -M 第1个字段到M N-M N到M个字段 cut 取的单位 -b 以字节为单位 -c 以字符为单位 -f 以字段为单位（使用定界符） paste 按列拼接文本 -d指明定界符 wc 统计行和字符的工具 wc -l file // 统计行数 wc -w file // 统计单词数 wc -c file // 统计字符数 sed 文本替换利器 首处替换: sed ‘s/text/replace_text/‘ file //替换每一行的第一处匹配的text 全局替换: sed ‘s/text/replace_text/g’ file 默认替换后，输出替换后的内容，如果需要直接替换原文件,使用-i: sed -i ‘s/text/repalce_text/g’ file awk 数据流处理工具awk脚本结构 1awk ' BEGIN{ statements } statements2 END{ statements } ' 执行begin中语句块； 从文件或stdin中读入一行，然后执行statements2，重复这个过程，直到文件全部被读取完毕； 执行end语句块；其他查看文件类型: file filename以ASCII字符显示文件: od -c filename 系统状态磁盘文件 df -h 查看磁盘空间利用 -h: human缩写，以易读的方式显示结果 du -sh -h 人性化显示 -s 递归整个目录的大小 打包压缩打包是将多个文件归并到一个文件: tar -cvf etc.tar /etc &lt;==仅打包，不压缩！ -c :打包选项 -v :显示打包进度 -f :使用档案文件 解包: tar -xvf demo.tar, -x 解包选项 tar解压参数说明： -z 解压gz文件 -j 解压bz2文件 -J 解压xz文件 压缩: gzip demo.txt,生成 demo.txt.gz解压缩：gunzip demo.tar.gz, 生成demo.tar同理bz2等 CPU监控 查看CPU使用率：sar -u 1 2，每1秒采样一次，总共采样2次； 查看CPU平均负载：sar -q 1 2 内存监控 内存使用状况：sar -r 1 2 查看内存使用量：free -m 查看页面交换发生状况 页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用sar -W这个命令来确认是否发生了大量的交换 当系统中sar不可用时，可以使用以下工具替代：linux下有 vmstat、Unix系统有prstat 查看cpu、内存、使用情况： vmstat n m （n 为监控频率、m为监控次数） 使用watch 工具监控变化 当需要持续的监控应用的某个数据变化时，watch工具能满足要求； 进程管理进程查询 查询正在运行的进程信息 ps -ef 查询归属于用户colin115的进程 ps -ef | grep colin115 或 ps -lu colin115 查询进程ID（适合只记得部分进程字段） pgrep 查找进程 eg:查询进程名中含有re的进程 pgrep -l re 以完整的格式显示所有的进程 ps -ajx 显示进程信息，并实时更新: top，输入字符命令后显示相应的进程状态 P：根据CPU使用百分比大小进行排序。 M：根据驻留内存大小进行排序。 i：使top不显示任何闲置或者僵死进程。 lsof命令查看文件使用： 查看端口占用的进程状态：lsof -i:3306 查看用户username的进程所打开的文件:lsof -u username 查询init进程当前打开的文件:lsof -c init 查询指定的进程ID(23295)打开的文件：lsof -p 23295 查询指定目录下被进程开启的文件（使用+D 递归目录）：lsof +d mydir1/ lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。 查询7902端口现在运行什么程序: 第一步，查询使用该端口的进程的PID；lsof -i:7902 使用ps工具查询进程详情：ps -fe | grep 30294 使用命令pmap，来输出进程内存的状况，可以用来分析线程堆栈。 终止进程 杀死指定PID的进程 (PID为Process ID)：kill PID 杀死相关进程：kill -9 3434 杀死job工作 (job为job number)：kill %job(job可以理解为shell的命令) 1234#将用户colin115下的所有进程名以av_开头的进程终止:ps -u colin115 | awk '/av_/ {print \"kill -9 \" $1}' | sh#将用户colin115下所有进程名中包含HOST的进程终止:ps -fe| grep colin115|grep HOST |awk '{print $2}' | xargs kill -9; 网络相关查询网络服务和端口 列出所有端口 (包括监听和未监听的): netstat -a 列出所有 tcp 端口: netstat -at 列出所有有监听的服务状态: netstat -l 网络路由 查看路由状态: route -n 发送ping包到地址IP: ping IP 探测前往地址IP的路由路径: traceroute IP DNS查询，寻找域名domain对应的IP: host domain 反向DNS查询: host IP 镜像下载直接下载文件或者网页:wget url常用选项: –limit-rate :下载限速 -o：指定日志文件；输出都写入日志； -c：断点续传 用户管理系统版本、时间、硬件IPC资源（Inter-Process Communication） 查看系统使用的IPC共享内存资源: ipcs -m 查看系统使用的IPC队列资源: ipcs -q 查看系统使用的IPC信号量资源: ipcs -s 应用示例：查看IPC资源被谁占用有个IPCKEY：51036 ，需要查询其是否被占用； 首先通过计算器将其转为十六进制:51036 -&gt; c75c 如果知道是被共享内存占用: ipcs -m | grep c75c 如果不确定，则直接查找: ipcs | grep c75c","link":"/2021/01/30/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-Linux/"},{"title":"LeetCode刷题记录","text":"","link":"/2021/01/14/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"算法&#x2F;异或用于交换证明","text":"","link":"/2021/03/31/%E7%AE%97%E6%B3%95/%E5%BC%82%E6%88%96%E7%94%A8%E4%BA%8E%E4%BA%A4%E6%8D%A2%E8%AF%81%E6%98%8E/"},{"title":"【C++】C++内存管理","text":"参考：https://zhuanlan.zhihu.com/p/51855842 为什么要内存对齐为了减少使用的内存为了提升数据读取的效率 内存对齐对于结构体变量内存对齐遵循以下三个原则： 变量的起始地址能够被其对齐值整除，结构体变量的对齐值为最宽的成员大小。 结构体每个成员相对于起始地址的偏移能够被其自身对齐值整除，如果不能则在前一个成员后面补充字节。 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节。 C++程序内存的布局(代码段或Text Segment)中存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。Data Segment中存放已初始化的全局或静态变量。BSS中存放未初始化的全局或静态变量。Heap(堆)，Stack(栈)， 栈（Stack） - 由编译器自动分配释放，用来存储函数调用时的临时信息，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。 在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。栈内存的申请和释放遵循LIFO(先进后出)。 2.堆（Heap） - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现(brk函数也是从这里分配内存)。 3.全局区/静态区（BSS），全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放 4.数据段（Data Segmen）存放已初始化的全局或静态变量。- 程序结束释放 5 代码区（Code Segment），存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排相同程序的多个运行实体共享这些实例代码。这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。 在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)，在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的”adgfdf”这样的字符串存放在常量区。","link":"/2020/12/22/C++/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"【C++】C++11新特性","text":"参考：https://blog.csdn.net/FX677588/article/details/70157088C++11,之前被称作C++0x，即ISO/IEC 14882:2011，是目前的C++编程语言的正式标准。 1、新增基于范围的for循环for(auto a: A)2、自动类型推断 auto3、匿名函数 Lambda [](int i){ return i+4};6、空指针常量 nullptr7、long long int类型8、线程支持,新的标准库提供了一个线程类(std::thread)来运行一个新线程，增加了互斥体(std::mutex, std::recursive_mutex等)和条件变量(std::condition_variable 和std::condition_variable_any)。","link":"/2020/12/22/C++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"【C++】extern关键字","text":"当它与”C”一起连用时，如: extern “C” void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的”脾气”了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释! 当extern不与”C”在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。","link":"/2020/12/22/C++/extern%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"【C++】const关键字","text":"参考：https://www.runoob.com/w3cnote/cpp-const-keyword.htmlconst 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。 1.const 修饰类的成员变量，表示成员常量，不能被修改。 2.const修饰函数承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。 3.如果 const 构成函数重载，const 对象只能调用 const 函数，非 const 对象优先调用非 const 函数。 4.const 函数只能调用 const 函数。非 const 函数可以调用 const 函数。 5.类体外定义的 const 成员函数，在定义和声明处都需要 const 修饰符。","link":"/2020/12/22/C++/const%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"【C++】new与malloc","text":"new和malloc的内存分配在堆上。也有说new是分配在自由存储区而malloc分配在堆上，自由存储区可以是堆也可以不是，具体要看new内部的实现。操作系统在堆上维护一个空闲内存链表，当需要分配内存的时候，就查找这个表，找到一块内存大于所需内存的区域，分配内存并将剩余的内存空间返还到空闲链表上（如果有剩余的话）。 new/delete和malloc/free的区别 malloc和free是库函数，而new和delete是C++操作符； new自己计算需要的空间大小，比如int * a = new，malloc需要指定大小，例如int * a = malloc(sizeof(int))； new在动态分配内存的时候可以初始化对象，调用其构造函数，delete在释放内存时调用对象的析构函数。而malloc只分配一段给定大小的内存，并返回该内存首地址指针，如果失败，返回NULL。 new是C++操作符，是关键字，而operate new是C++库函数 opeartor new /operator delete可以重载，而malloc不行 new可以调用malloc来实现，但是malloc不能调用new来实现 对于数据C++定义new[] 专门进行动态数组分配，用delete [] 进行销毁。new[] 会一次分配内存，数量一般存储在返回地址前的四个字节，然后多次调用构造函数；delete[]会先多次调用析构函数，然后一次性释放。 分配数组不同之处 12int char* pa = new char[100];int char* pb = malloc(sizeof(char) * 100); malloc能够直观地重新分配内存 使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。 new没有这样直观的配套设施来扩充内存。","link":"/2020/12/22/C++/new%E4%B8%8Emalloc/"},{"title":"【C++】拷贝构造和赋值构造","text":"参考：https://blog.csdn.net/windgs_yf/article/details/80899901 构造函数：构造函数是用来创建一个对象的时候的调用的函数，构造函数可以重载，也就是一 个类可以包含多个构造函数只要每两个构造函数的形参不相同即可。拷贝构造函数：拷贝构造函数也属于构造函数的一种，同样是在创建一个对象的时候会调用，只不过是用另一个对象来创建一个新的对象赋值运算符（=）：赋值运算符是在将一个对象赋值(=)给另一个对象的时候调用的函数。 例子1234String a(“hello”);String b(“world”);String c = a; // 调用了拷贝构造函数，最好写成 c(a);c = b; // 调用了赋值函数 本例中第三个语句的风格较差，宜改写成String c(a) 以区别于第四个语句。 拷贝构造函数1234567String::String(const String &amp;other){ // 允许操作other 的私有成员m_data int length = strlen(other.m_data); m_data = new char[length+1]; strcpy(m_data, other.m_data);} 类String 拷贝构造函数与普通构造函数的区别是：在函数入口处无需与NULL 进行比较，这是因为“引用”不可能是NULL，而“指针”可以为NULL。 赋值函数1234567891011121314String &amp; String::operator =(const String &amp;other){ // (1) 检查自赋值 if(this == &amp;other) return *this; // (2) 释放原有的内存资源 delete [] m_data; // （3）分配新的内存资源，并复制内容 int length = strlen(other.m_data); m_data = new char[length+1]; strcpy(m_data, other.m_data); // （4）返回本对象的引用 return *this;} 补充拷贝构造，是定义一个对象，初始化一边内存区域，这边内存区域就是你的新对象的内存区域。赋值运算，是对于一个已经被初始化的对象来进行operator=操作 一般来说是在数据成员包含指针对象的时候，有两种不同的处理需求:一种是复制指针对象，一种是引用指针对象。拷贝构造大多数情况下是复制，=则是引用对象的 拷贝构造函数是构造函数，不返回值而赋值函数需要返回一个对象自身的引用，以便赋值之后的操作","link":"/2020/12/22/C++/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0/"},{"title":"【C++】static关键字","text":"static是C和C++的关键词，static在C++中比在C中有着更丰富的用法。 static修饰局部变量static修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序退出时销毁。（无论是局部静态还是全局静态）局部静态变量使得该变量在退出函数后，不会被销毁，因此再次调用该函数时，该变量的值与上次退出函数时值相同。值得注意的是，生命周期并不代表其可以一直被访问，因为变量的访问还受到其作用域的限制。 static修饰全局变量全局变量本来就存储在静态区，因此static并不能改变其存储位置。但是，static限制了其链接属性。被static修饰的全局变量只能被该包含该定义的文件访问。在头文件a.h中定义一个全局变量 static修饰函数static修饰函数使得函数只能在包含该函数定义的文件中被调用。在头文件b.h中声明静态函数fun()，在文件b.cpp中定义静态函数fun()，编译器会报错，指明b.h中的fun函数未定义。 对于静态函数，声明和定义需要放在同一个文件夹中。 如果将static函数定义在头文件中，则每一个包含该头文件的文件都实现了一个fun函数。因此static实现了不同文件中定义同名的函数，而不发生冲突。 在多人协同工作的项目中，为了避免出现同名的函数冲突，可以将函数定义为static，从而避免冲突的发生。 static在C++中的作用（修饰类的成员）在C++中static不光具备C中所有的作用，而且对于静态成员变量和静态成员函数。所有的对象都只维持同一个实例。因此，采用static可以实现不同对象之间数据共享。","link":"/2020/12/22/C++/static%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"【C++】指针和引用的区别","text":"参考：https://www.cnblogs.com/dolphin0520/archive/2011/04/03/2004869.html 指针和引用的定义和性质区别： (1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如： 123int a=1;int *p=&amp;a;//p的值是a存储单元的地址。int &amp;b=a; //事实上a和b是同一个东西，在内存为同一个存储单元。 (2)可以有const指针，但是没有const引用； (3)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的） (4)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化； (5)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。 (6)”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小； (7)指针和引用的自增(++)运算意义不一样，引用使变量自增，指针表示地址增加（用于数组）。","link":"/2020/12/22/C++/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"【C++】volatile关键字","text":"参考：https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的 memory barrier。volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。 声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如： 12345volatile int i=10;int a = i;...// 其他代码，并未明确告诉编译器，对 i 进行过操作int b = i; volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。","link":"/2020/12/22/C++/volatilte%E5%85%B3%E9%94%AE%E5%AD%97/"},{"title":"【C++】必须在构造函数初始化列表里进行初始化的数据成员","text":"参考：https://blog.csdn.net/cloud323/article/details/**71743176** 下面是一个自定义的Student类 12345678910class Address{}; class Student{private: const int grade; string &amp;name; Address addr;public: Student(int grade, string name):grade(grade), name(name){}}; 常量成员 常量成员只能初始化不能赋值，所以必须放在初始化列表里。 引用类型 引用必须在定义时初始化，并且不能重新赋值，所以必须放在初始化表里。 对象成员 这个成员是其他类的对象，例如上面的Address addr成员。如果把它放在构造函数的初始化列表里，此时会调用Address类的copy constructor函数，对这个类对象进行初始化。如果把它放在构造函数体中，会先调用Address类的default constructor函数，然后再调用Address类的copy constructor函数。从性能上考虑，把对象成员的初始化放在初始化列表里性能会更高。","link":"/2020/12/22/C++/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"},{"title":"【OS】IO多路复用","text":"参考：https://www.cnblogs.com/Anker/p/3265058.htmlselect，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 select的几大缺点：（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（3）select支持的文件描述符数量太小了，默认是1024 poll实现poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。 epoll epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。 对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。 对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。 epoll工作模式LT(level triggered) 是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。ET (edge-triggered) 是高速工作方式，只支持no-block socket。 在这种模式下，当描述符从未就绪变为就绪时，内核就通过epoll告诉你，然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作而导致那个文件描述符不再是就绪状态。不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。 总结：（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。 （2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。","link":"/2021/03/19/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"title":"【C++】虚函数","text":"参考：https://blog.csdn.net/haoel/article/details/1948051/C++多态(polymorphism)是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，即为动态绑定。 纯虚函数纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” 。包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。 虚函数表对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，包含一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。 一般继承（无虚函数覆盖）1）虚函数按照其声明顺序放于表中。2）父类的虚函数在子类的虚函数前面。 一般继承（有虚函数覆盖）1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。2）没有被覆盖的函数依旧。 多重继承（无虚函数覆盖）1） 每个父类都有自己的虚表。2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） 多重继承（有虚函数覆盖）多个父类虚函数表中的f()的位置被替换成了子类的函数指针。 虚函数表存放虚函数表与类绑定，每个类有对应的虚函数表，编译时确定，对象有指向对应虚函数表的指针。虚函数表类似于类中静态成员变量。存放在全局数据区。","link":"/2020/12/22/C++/%E8%99%9A%E5%87%BD%E6%95%B0/"},{"title":"【OS】Linux内存管理","text":"参考：https://www.cnblogs.com/cxuanblog/p/13390654.html https://www.cnblogs.com/yunsicai/p/3326105.htmlhttps://www.cnblogs.com/cxuanblog/p/13390654.html","link":"/2021/03/19/OS/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"【OS】内存泄露","text":"参考：https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。 堆内存泄漏(Heap leak)堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。 系统资源泄漏指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 检测方法(1)在windows平台下通过CRT中的库函数进行检测；(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置(3)Linux下通过工具valgrind检测","link":"/2021/03/06/OS/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"},{"title":"【OS】Linux常用性能监控命令","text":"Linux常用性能监控命令有哪些 磁盘文件 df -h 查看磁盘空间利用 -h: human缩写，以易读的方式显示结果 du -sh -h 人性化显示 -s 递归整个目录的大小 CPU监控 查看CPU使用率：sar -u 1 2，每1秒采样一次，总共采样2次； 查看CPU平均负载：sar -q 1 2 内存监控 内存使用状况：sar -r 1 2 查看内存使用量：free -m 查看页面交换发生状况 页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用sar -W这个命令来确认是否发生了大量的交换 当系统中sar不可用时，可以使用以下工具替代：linux下有 vmstat、Unix系统有prstat 查看cpu、内存、使用情况： vmstat n m （n 为监控频率、m为监控次数） 使用watch 工具监控变化 当需要持续的监控应用的某个数据变化时，watch工具能满足要求； 查询网络服务和端口 列出所有端口 (包括监听和未监听的): netstat -a 列出所有 tcp 端口: netstat -at 列出所有有监听的服务状态: netstat -l IPC资源（Inter-Process Communication） 查看系统使用的IPC共享内存资源: ipcs -m 查看系统使用的IPC队列资源: ipcs -q 查看系统使用的IPC信号量资源: ipcs -s 应用示例：查看IPC资源被谁占用有个IPCKEY：51036 ，需要查询其是否被占用； 首先通过计算器将其转为十六进制:51036 -&gt; c75c 如果知道是被共享内存占用: ipcs -m | grep c75c 如果不确定，则直接查找: ipcs | grep c75c 进程查询 查询正在运行的进程信息 ps -ef 查询归属于用户colin115的进程 ps -ef | grep colin115 或 ps -lu colin115 查询进程ID（适合只记得部分进程字段） pgrep 查找进程 eg:查询进程名中含有re的进程 pgrep -l re 以完整的格式显示所有的进程 ps -ajx 显示进程信息，并实时更新: top，输入字符命令后显示相应的进程状态 P：根据CPU使用百分比大小进行排序。 M：根据驻留内存大小进行排序。 i：使top不显示任何闲置或者僵死进程。 lsof命令查看文件使用： 查看端口占用的进程状态：lsof -i:3306 查看用户username的进程所打开的文件:lsof -u username 查询init进程当前打开的文件:lsof -c init 查询指定的进程ID(23295)打开的文件：lsof -p 23295 查询指定目录下被进程开启的文件（使用+D 递归目录）：lsof +d mydir1/ lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。 查询7902端口现在运行什么程序: 第一步，查询使用该端口的进程的PID；lsof -i:7902 使用ps工具查询进程详情：ps -fe | grep 30294 使用命令pmap，来输出进程内存的状况，可以用来分析线程堆栈。","link":"/2021/03/10/OS/Linux%E5%B8%B8%E7%94%A8%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4/"},{"title":"【OS】线程安全的方法","text":"参考：https://zhuanlan.zhihu.com/p/87682798 当多个线程同时操作同一个共享全局变量的时候，就容易出现线程安全问题，由于执行的时序不一样，就会导致主存的值被多个线程修改，会导致安全问题。锁解决资源占用的问题；保证同一时间一个对象只有一个线程在访问；保证数据的安全性。 公平锁与非公平锁公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。公平锁的好处是，可以保证每个排队的线程都能获得锁，先到先得。但是弊端是，要额外数据保存顺序。非公平锁：非公平锁不用排队，当锁被释放时，线程抢占锁，可能会造成饥饿问题。 互斥锁从能否有多个线程持有同一把锁的角度划分互斥锁的概念非常简单，也就是我们常说的同步，即一次最多只能有一个线程持有的锁，当一个线程持有该锁的时候其它线程无法进入上锁的区域。 重入锁（递归锁）与 不可重入锁（自旋锁）从一个线程能否递归获取自己的锁的角度划分我们知道，一条线程若想进入一个被上锁的区域，首先要判断这个区域的锁是否已经被某条线程所持有。可重入锁：可以再次获取获得的锁，就是说在释放锁前此线程可以再次进入获取锁的方法 A（方法 A 递归）。不可重入锁（自旋锁）：不可以再次获取获得的锁，也就是说获得锁进入方法 A 是此线程在释放锁前唯一的一次进入方法 A。 悲观锁与乐观锁悲观锁悲观锁是就是悲观思想，即认为读少写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。 乐观锁乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读。 共享锁、排它锁共享锁和排它锁多用于数据库中的事物操作，主要针对读和写的操作。即一条线程进行读的时候，允许其他线程进入上锁的区域中进行读操作；当一条线程进行写操作的时候，不允许其他线程进入进行任何操作。即读 + 读可以存在，读 + 写、写 + 写均不允许存在 共享锁：也称读锁或 S 锁。如果事务 T 对数据 A 加上共享锁后，则其他事务只能对 A 再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。排它锁：也称独占锁、写锁或 X 锁。如果事务 T 对数据 A 加上排它锁后，则其他事务不能再对 A 加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。 原子操作​ 何谓原子性操作，即为最小的操作单元，比如i=1，就是一个原子性操作，这个过程只涉及一个赋值操作。又如i++就不是一个原子操作，它相当于语句i=i+1；这里包括读取i，i+1，结果写入内存三个操作单元。","link":"/2021/03/17/OS/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81/"},{"title":"【C++】指针和引用的区别","text":"参考：https://www.cnblogs.com/xiehongfeng100/p/4645555.html解决内存泄露和野指针的问题。 智能指针是一个存储指向动态分配（堆）对象指针的类，构造函数传入普通指针，析构函数释放指针。栈上分配，函数或程序结束自动释放，防止内存泄露。使用引用计数器； unique_ptr， 不支持复制和赋值，直接赋值会编译出错。shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。 智能指针的循环引用怎么回事？如何解决？两个指针相互指向对方，析构时由于引用计数不为0导致内存泄漏。方法：采用弱引用的weak_ptr即可。弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。 智能指针是线程安全的吗？shared_ptr 本身不是 100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是。","link":"/2020/12/22/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"title":"【OS】进程间通信","text":"参考：https://www.jianshu.com/p/c1015f5ffa74 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication） 管道/匿名管道(pipe)管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 只支持单向数据流； 只能用于具有亲缘关系的进程之间； 没有名字； 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）； 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等； 有名管道(FIFO)有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。有名管道的名字存在于文件系统中，内容存放在内存中。 匿名管道和有名管道总结：（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。（3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。（4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。 信号(Signal)信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。 （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；（2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。（3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。 消息(Message)队列消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。 消息队列特点总结：（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.（2）消息队列允许一个或多个进程向它写入与读取消息.（3）管道和消息队列的通信数据都是先进先出的原则。（4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。（5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。（6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。 共享内存(share memory)使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。 信号量(semaphore)信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。为了获得共享资源，进程需要执行下列操作：（1）创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。（2）等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。（3）挂出一个信号量：该操作将信号量的值加1，也称为V操作。 为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）、Posix基于内存的信号量（存放在共享内存区中）、System V信号量（在内核中维护）。这三种信号量都可用于进程间或线程间的同步。 信号量与互斥量之间的区别：（1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源（2）互斥量值只能为0/1，信号量值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。（3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。 套接字(socket)套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。","link":"/2021/03/06/OS/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},{"title":"【OS】进程和线程","text":"进程与线程区别？多进程和多线程健壮性？linux中的线程？ 二者比较1. 定义进程是操作系统资源分配的基本单位；线程是CPU调度、程序执行的最小单元。 进程包含可执行程序代码、系统资源（打开的文件、挂起的信号、内存地址空间、一或多个执行线程等），进程是正在执行的程序代码的实时结果。 线程是在进程中活动的对象，包含独立的程序计数器、线程栈和寄存器。内核的调度对象是线程。 2.内存进程有独立的地址空间，而同一进程中的线程共享该进程的地址空间。比如在linux下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。 而运行一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。 3.通信线程之间的通信比较方便。统一进程下的线程共享数据（比如全局变量，静态变量，打开的文件，子进程），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。 而进程之间的通信只能通过进程通信的方式进行。 对同一进程中的线程，在一个线程中分配的堆在各个线程中均可以使用，在一个线程中打开的文件各个线程均可用。 4.执行线程的执行与进程是有区别的。每个独立的进程有有自己的一个程序入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依附于程序之中，由应用程序提供多个线程的并发控制。 5.多进程和多线程多进程比多线程程序要健壮。一个线程死掉整个进程就死掉了，但是在保护模式下，一个进程死掉对另一个进程没有直接影响。 6.linux中linux对线程和进程并不特别区分，线程是一种特殊的进程，一种与其他进程共享某些资源的进程。 linux中进程具有父子关系，形成进程树，但是线程是平等的没有父子关系。","link":"/2021/03/06/OS/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"},{"title":"【OS】虚拟内存","text":"虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。 工作过程工作过程包括6个步骤： 中央处理器访问主存的逻辑地址分解成组号a和组内地址b，并对组号a进行地址变换，即将逻辑组号a作为索引，查地址变换表，以确定该组信息是否存放在主存内。 如该组号已在主存内，则转而执行4；如果该组号不在主存内，则检查主存中是否有空闲区，如果没有，便将某个暂时不用的组调出送往辅存，以便将这组信息调入主存。 从辅存读出所要的组，并送到主存空闲区，然后将那个空闲的物理组号a和逻辑组号a登录在地址变换表中。 从地址变换表读出与逻辑组号a对应的物理组号a。 从物理组号a和组内字节地址b得到物理地址。 根据物理地址从主存中存取必要的信息。 调度方式页式调度虚拟空间被分成大小相等的页，称为逻辑页或虚页。主存空间也被分成同样大小的页，称为物理页或实页。相应地，虚拟地址分为两个字段:高位字段为虚页号，低位字段为页内地址。实存地址也分为两个字段：高位字段为实页号，低位字段为页内地址。 通过页表可以把虚拟地址转换成物理地址。每个程序设置一张页表，在页表中，对应每一个虚页号都有一个条目，条目内容至少包含该虚页所在的主存页面地址(实页号)，用它作为实存地址的高位字段;实页号与虚拟地址的页内地址相拼接，就产生完整的实存地址，据此访问主存。 页式调度的优点是页内零头小，页表对程序员来说是透明的，地址变换快，调入操作简单；缺点是各页不是程序的独立模块，不便于实现程序和数据的保护。 段式调度段是按照程序的自然分界划分的、长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。 在段式虚拟存储系统中，虚拟地址由段号和段内地址组成，虚拟地址到实存地址的变换通过段表来实现。每个程序设置一个段表，段表的每一个表项对应一个段，每个表项至少包括三个字段：有效位(指明该段是否已经调入主存)、段起址(该段在实存中的首地址)和段长(记录该段的实际长度)。 段页式调度段页式虚拟存储器是段式虚拟存储器和页式虚拟存储器的结合。 首先，实存被等分成页。在段页式虚拟存储器中，把程序按逻辑结构分段以后，再把每段按照实存的页的大小分页，程序按页进行调入和调出操作，但它又可按段实现共享和保护。因此，它可以兼有页式和段式系统的优点。它的缺点是在地址映像过程中需要多次查表，虚拟地址转换成物理地址是通过一个段表和一组页表来进行定位的。段表中的每个表目对应一个段，每个表目有一个指向该段的页表的起始地址(页号)及该段的控制保护信页表指明该段各页在主存中的位置以及是否已装入、已修改等标志。 替换算法替换规则用来确定替换主存中哪一部分，以便腾空部分主存，存放来自辅存要调入的那部分内容。常见的替换算法有4种。 随机算法：用软件或硬件随机数产生器确定替换的页面。 先进先出：先调入主存的页面先替换。 近期最少使用算法（LRU，Least Recently Used）：替换最长时间不用的页面。 最优算法：替换最长时间以后才使用的页面。 补充在 Windows中，虚拟内存其实是一个容量很大的文件 pagefile. sys，称之为页面文件。CPU 中有一种硬件，内存管理单元 MMU（Memory Management Unit）专门用来将翻译虚拟内存地址。","link":"/2021/03/19/OS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"},{"title":"【基础】ARP和ARP攻击","text":"在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。负责将某个IP地址解析成对应的MAC地址。 如何知道IP对应的MAC地址 每台主机都会在自己的ARP缓冲区建立一个ARP列表（生命周期二十分钟），用于表示IP地址和MAC地址的对应关系。 主机A若想和主机B通信，首先主机A会查询Arp缓存表（后面称ip-mac缓存表）是否有B主机对应的ip-mac，有的话就将B主机的mac地址封装到数据包发送。若没有的话，主机A会向以太网发送一个Arp广播包，告诉以太网内的所有主机自己的ip-mac，并请求B主机（以ip来表示B主机）的mac地址。当B主机收到Arp广播包后，确认A主机是想找自己的mac地址，就会对A主机进行回应一个自己的mac地址。A主机就会更新自己的ip-mac缓存表，同时B主机也会接收A主机的ip-mac对应关系到自己的ip-mac缓存表。 ARP攻击ARP协议信任以太网所有的节点，只要它就收到的arp广播包，他就会把对应的ip-mac更新到自己的缓存表，根据以上说的arp协议缺陷，如果我们冒充网关主机C，不停的向以太网发送自己的ARP广播包，告知自己的ip-mac，此时其它主机就会被欺骗，更新我们C的ip-mac为网关主机的ip-mac，那么其它主机的数据包就会发送到C主机上，因为没有发给真正的网关，就会造成其它主机的网络中断。","link":"/2021/03/17/%E5%9F%BA%E7%A1%80/ARP%E5%92%8CARP%E6%94%BB%E5%87%BB/"},{"title":"【每日一题_基础】ARP和ARP攻击","text":"参考：https://itbilu.com/other/relate/EkwKysXIl.htmlHTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。 GETGET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。 POSTPOST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。 HEADHEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。 PUTPUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。 DELETEDELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。 CONNECTCONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。 OPTIONSOPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许 TRACETRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。 HTTP/1.1之后增加的方法在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同： 但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。 HTTP的幂等性（补充）HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。 HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。比如：GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。 HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。 比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的： POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。 在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id?amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。","link":"/2021/03/17/%E5%9F%BA%E7%A1%80/HTTP%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"【基础】HTTP和HTTPS","text":"HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 基本概念HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTPS工作过程1、客户端发起HTTPS请求用户在浏览器里输入一个https网址，然后连接到server的443端口。 2、服务端的配置采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。 3、传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的版本号、序列号、签名算法、颁发机构，对应域名，过期时间等等。 4、客户端解析证书这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。 验证证书的方法：CRL（Certificate Revocation List）即 证书撤销名单。证书颁发者会提供一份已经失效证书的名单，供浏览器验证证书使用。当然这份名单是巨长无比的，浏览器不可能每次TLS都去下载，所以常用的做法是浏览器会缓存这份名单，定期做后台更新。这样虽然后台更新存在时间间隔，证书失效不实时，但一般也OK。OCSP(Online Certificate StatusProtocol)即 在线证书状态协议。除了离线文件，证书颁发者也会提供实时的查询接口，查询某个特定证书目前是否有效。实时查询的问题在于浏览器需要等待这个查询结束才能继续TLS握手，延迟会更大。 5、传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6、服务段解密信息服务端用私钥解密后，得到了客户端传过来的随机值(会话密钥)，然后把内容通过该值进行对称加密。 7、传输加密后的信息这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 8、客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。 HTTP与HTTPS的区别？简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS和HTTP的区别主要如下： 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTPS的优点正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，从站长的角度来说，HTTPS的优点有以下2点： 1、SEO方面 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 2、安全性 尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处： （1）、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 HTTPS的缺点虽然说HTTPS有很大的优势，但其相对来说，还是有些不足之处的，具体来说，有以下2点： 1、SEO方面 据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响。而且HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 2、经济方面（1）、SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。（2）、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。（3）、HTTPS连接缓存不如HTTP高效，大流量网站如非必要也不会采用，流量成本太高。（4）、HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用HTTPS，基于大部分计算资源闲置的假设的VPS的平均成本会上去。（5）、HTTPS协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。","link":"/2021/03/17/%E5%9F%BA%E7%A1%80/HTTP%E5%92%8CHTTPS/"},{"title":"【基础】HTTP版本","text":"参考：https://juejin.cn/post/6844903923136856078 HTTP 协议从开始立项到现在一共经历了 4 个版本: HTTP 0.9 -&gt; HTTP 1.0 -&gt; HTTP 1.1 -&gt; HTTP 2 HTTP 0.9HTTP 0.9 是一个最古老的版本只支持GET请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息没有请求头概念：所以不能在请求中指定版本号，服务端也只具有返回 HTML字符串的能力服务端相响应之后，立即关闭TCP连接 HTTP 1.0请求方式新增了POST，DELETE，PUT，HEADER等方式增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输 在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。 一个简单请求的头信息 123GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */* 复制代码可以看到在请求方法之后有 请求资源的位置 + 请求协议版本，之后是一些客户端的信息配置响应头 一个简单响应的头信息(v1.0) 1234567HTTP/1.0 200 OKContent-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMT// 这是一个空行...数据内容 复制代码服务端的响应头第一个就是 请求协议版本，后面紧跟着是这次请求的状态码、以及状态码的描述，之后的内容是一些关于返回内容的描述。 在 HTTP 1.0 的时候，任何的资源都可以被传输，传输的格式呢也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 Content-Type 去进行解析的。所以服务端返回时候必须带着这个字段。这些 Content-Type 有一个总称叫做MIME type。 特性无状态：服务器不跟踪不记录请求过的状态,借助cookie/session机制来做身份认证和状态记录无连接：浏览器每次请求都需要建立tcp连接,无连接导致的性能缺陷有两种： 无法复用连接,每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低 队头阻塞，HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的 HTTP 1.1HTTP 1.1 是在 1.0 发布之后的半年就推出了，完善了 1.0 版本。目前也还有很多的互联网项目基于 HTTP 1.1 在向外提供服务。 特性长连接：HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据，新增Connection字段，可以设置keep-alive值保持连接不断开管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回，虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题缓存处理：当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。通过设置字段cache-control来控制缓存。断点传输：在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率 HTTP 2特性:二进制分帧：HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率多路复用： 在共享TCP链接的基础上同时发送请求和响应，基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来。头部压缩：由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源，详见 HTTP/2 头部压缩技术介绍。服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求","link":"/2021/03/17/%E5%9F%BA%E7%A1%80/HTTP%E7%89%88%E6%9C%AC/"},{"title":"【基础】TCP三次握手、四次挥手","text":"传输控制协议（英語：Transmission Control Protocol，縮寫：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，参考：https://blog.csdn.net/qzcsu/article/details/72861891 三次握手 为什么TCP客户端最后还要发送一次确认呢？一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 四次挥手 为什么客户端最后还要等待2MSL？MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 为什么建立连接是三次握手，关闭连接确是四次挥手呢？建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。 如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。","link":"/2021/03/13/%E5%9F%BA%E7%A1%80/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"title":"【基础】SYN洪水攻击","text":"SYN攻击利用的是TCP的三次握手机制，攻击端利用伪造的IP地址向被攻击端发出请求，而被攻击端发出的响应 报文将永远发送不到目的地，那么被攻击端在等待关闭这个连接的过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。 SYN洪水可以以三种不同的方式发生： 直接攻击IP地址不被欺骗的SYN Flood被称为直接攻击。在这次攻击中，攻击者根本不掩盖其IP地址。由于攻击者使用具有真实IP地址的单个源设备来创建攻击，因此攻击者极易受到发现和缓解的影响。为了在目标机器上创建半开状态，黑客可以防止其机器响应服务器的SYN-ACK数据包。这通常是通过阻止除SYN数据包之外的传出数据包的防火墙规则来实现的，或者在到达恶意用户机器之前过滤任何传入的SYN-ACK数据包。实际上，这种方法很少使用（如果有的话），因为减轻是非常简单的 – 只是阻止每个恶意系统的IP地址。 欺骗性攻击：恶意用户也可以欺骗他们发送的每个SYN数据包上的IP地址，以抑制缓解工作，使其身份更难发现。虽然数据包可能被欺骗，但这些数据包可能会被追溯到其来源。很难做这种侦探工作，但并不是不可能的，特别是如果互联网服务提供商（ISP）愿意帮助的话。 分布式攻击（DDoS）：如果使用僵尸网络创建攻击，则将攻击溯源到源的可能性很低。对于增加的混淆级别，攻击者可能会使每个分布式设备也欺骗发送数据包的IP地址。如果攻击者正在使用诸如未来僵尸网络的僵尸网络，他们通常不会关心被感染设备的IP掩蔽 通过使用SYN Flood攻击，恶意攻击者可以尝试在目标设备或服务中创建拒绝服务，其流量大大低于其他DDoS攻击。为了使目标周边的网络基础设施饱和，SYN攻击只需要比目标操作系统中可用的积压更大的体积攻击。如果攻击者能够确定积压的大小，并且在超时之前每个连接将被打开多长时间，攻击者可以定位禁用系统所需的确切参数，从而将总流量减少到最小必要量以创建拒绝服务。 缓解途径 增加积压队列 目标设备上的每个操作系统都具有一定数量的半开放连接。对大量SYN数据包的一个响应是增加操作系统允许的可能半开连接的最大数量。为了成功增加最大积压，系统必须预留额外的内存资源来处理所有新的请求。如果系统没有足够的内存来处理增加的积压队列大小，系统性能将受到负面影响，但仍然可能优于拒绝服务。 回收最早的半开TCP连接 一旦积压已被填补，另一个缓解策略就是覆盖最早的半开式连接。这种策略要求合法连接可以在比可以填充恶意SYN数据包的积压时间更短的时间内完全建立。当攻击量增加时，或者如果积压量太小而不实际，这种特定的防御就会失败。 SYN cookie这个策略涉及服务器创建一个cookie。为了避免在积压已经被填满的情况下连接丢失的风险，服务器使用SYN-ACK数据包对每个连接请求进行响应，然后从积压中删除SYN请求，从存储器中删除请求并使端口打开，准备建立新的连接。如果连接是合法请求，并且最终的ACK数据包从客户端计算机发送回服务器，则服务器将重建（有一些限制）SYN积压队列条目。尽管这种缓解措施确实丢失了有关TCP连接的一些信息，但是优于允许合法用户因攻击而发生拒绝服务。 补充攻击者可以使用 ICMP 洪水攻击（即发送大量 ICMP 相关报文）、或者 UDP 洪水攻击（即发送用户数据报协议的大包或小包），使用伪造源 IP 地址方式进行隐匿，并对网络造成拥堵和服务器响应速度变慢等影响。","link":"/2021/03/17/%E5%9F%BA%E7%A1%80/SYN%E6%B4%AA%E6%B0%B4%E6%94%BB%E5%87%BB/"},{"title":"【基础】TCP分段和IP分片","text":"TCP报文段如果很长的话，会在发送时发生分段(Segmentation)，在接收时进行重组，同样IP数据报在长度超过一定值时也会发生分片(Fragmentation)，在接收端再将分片重组。https://cloud.tencent.com/developer/article/1173790 要点最大传输单元(Maximum Transmission Unit)，即MTU，为数据链路层的最大载荷上限(即IP数据报最大长度)，每段链路的MTU可能都不相同，一条端到端路径的MTU由这条路径上MTU最小的那段链路的MTU决定。以以太网为例，MTU通常为1500字节，采用巨帧(Jumbo Frame)时可以达到9000字节。所谓的MTU， 最大报文段长度(Maximum Segment Size)，即MSS，为TCP传输层的最大载荷上限(即应用层数据最大长度)，TCP三次握手期间通过TCP首部选项中的MSS字段通知对端，通常一条TCP连接的MSS取通信双方较小的那一个MSS值， MSS与MTU的换算关系为：MTU = MSS + TCP首部长度 + IP首部长度 以太网中(网络层以IPv4为例)：MSS = 以太网MTU - TCP首部长度 - IPv4首部长度 = 1500 - 20 - 20 = 1460字节 UDP不会分段，就由IP来分片。TCP会分段，当然就不用IP来分了。 在分片的数据中，传输层的首部只会出现在第一个分片中，IP数据报分片后，只有第一片带有传输层首部(UDP或ICMP等)，而TCP报文段的每个分段中都有TCP首部，到了目的地后根据TCP首部的信息在传输层进行重组。 TCP分段技术被提出后，在一定程度上减少了IP分片，但是却不能保证在整个端到端通信路径上不会发生IP分片。 IP首部中有三个标志位，第一位预留，第二位DF(Don’t Fragment)，第三位MF(More Fragments)。DF置1，通过是否丢包，ICMP通知MTU，","link":"/2021/03/17/%E5%9F%BA%E7%A1%80/TCP%E5%88%86%E6%AE%B5%E5%92%8CIP%E5%88%86%E7%89%87/"},{"title":"【基础】TCP和UDP的区别","text":"TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。 UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。 比较 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅8字节 首部最小20字节，最大60字节 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 头部 UDP头总长度：8字节源端口号发送方端口号，需要对方回信时使用，不需要可以全用0， 目的端口号目的端口号。终点交付报文时必须使用 长度UDP数据报长度,最小值8 检验和检测UDP用户数据包在传输中是否有错 TCP头总长度：20字节源端口和目的端口，各占2个字节，分别写入源端口和目的端口；序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；保留，占6位，保留今后使用，但目前应都位0；紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；检验和，占2字节，校验首部和数据这两部分；紧急指针，占2字节，指出本报文段中的紧急数据的字节数；选项，长度可变，定义一些其他的可选的参数。 IP首部总长度：20字节","link":"/2021/03/13/%E5%9F%BA%E7%A1%80/TCP%E5%92%8CUDP%E5%8C%BA%E5%88%AB/"},{"title":"【基础】TCP三次握手、四次挥手","text":"发送窗口：TCP中为了解决应答机制等待时间过长而引入的方法，如果没有窗口，则TCP每发送一次数据就必须等待应答，收到应答后继续发送，如果没有收到则等待一段时间后重发，如果很长时间都无法收到应答则判断为网络断开。而使用窗口后，窗口的大小指无需等待应答可以连续发送多个数据包。 接收窗口：TCP头部带有窗口，用于指示接收窗口大小。 拥塞窗口：根据网络情况确定的发送窗口大小，考虑到网络中的拥堵，比如路由器要处理的数据过多，导致缓冲区溢出而丢包。 发送时选择两者中小的作为发送窗口大小。 关键词慢启动，快速重传，快速恢复。拥塞窗口和慢启动阀值。 过程 通信开始时，发送方的拥塞窗口大小为 1。每收到一个 ACK 确认后，拥塞窗口大小加1。窗口大小成指数增长。（慢启动） 由于指数级增长非常快，很快地，就会出现确认包超时，认为发生了拥塞。 此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。 拥堵发生后将拥塞窗口大小设置为 1，重新进入慢启动过程。 由于现在“慢启动阈值”已经存在，当拥塞窗口大小达到阈值后，停止使用慢启动算法，开始采用拥塞避免算法。窗口大小开始线性增加。 随着窗口大小不断增加，如果收到三次重复确认应答，则进入“快速重发”阶段。对于这用拥塞情况，TCP 将“慢启动阈值”设置为当前拥塞窗口大小的一半，再将拥塞窗口大小设置成阈值大小（也有说加 3）。然后采用拥塞避免算法增加窗口大小。 随着窗口大小不断增加，如果发生超时。对于这种拥塞情况，TCP将满启动阀值设置为当前拥塞窗口的一半，然后将拥塞窗口设置为1。 重传超时重传（RTO）当一个包被发送后，就开启一个定时器，如果定时时间到了，还未收到能确认该发送包的应答包，就重传一份数据。注意收到的应答包可能是该包也可能是后面包的，但是只要能确认该包被收到就行。另外如果，是因为网络延时造成重传，则接受端收到重复数据包后丢弃该包。 快速重传当如果发送端收到一个包的三次应答包后，立即重传，比超时重传更高效。 参考：https://blog.csdn.net/shanghairuoxiao/article/details/68927100","link":"/2021/03/28/%E5%9F%BA%E7%A1%80/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"},{"title":"【基础】几种NAT类型","text":"参考https://blog.csdn.net/mycloudpeak/article/details/53550405 NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。 NAT缓解了IPV4地址不够用的问题，同时也也带了限制，那就是NAT外部的主机无法主动跟位于NAT内部的主机通信，NAT内部主机想要通信，必须主动和公网的一个IP通信，网关负责建立一个映射关系，从而实现数据的转发， 这就是NAT的工作原理。 分类NAT可以根据映射建立的依据分成两大类：锥型（Cone）和对称型（Symmetric） 锥形和对称型的区别在于：锥型映射的建立是根据内部主机的IP和端口号，对称型映射的建立是根据连接（即内部IP端口+目的IP端口）。 如：Client192.168.0.2:100发送报文给Server11.1.1.1:1111，两种NAT都会建立映射，比如映射到网关8.8.8.8:100。当Client192.168.0.2:100发送报文给Server22.2.2.2:1111时，锥型会直接使用之前映射的8.8.8.8:100发送，而对称型会重新建立映射，比如映射到8.8.8.8:101。 锥型细分锥型NAT又可以根据其对发送到映射后公网的IP端口报文如何处理细分为： 全锥型(Full Cone) 受限锥型(Restricted Cone)， 或IP受限锥型 端口受限锥型(Port Restricted Cone), 或IP + PORT受限锥型 client192.168.0.2, 100和server1.1.1.1:1111在通信后，映射到网关8.8.8.8:100，如果这个时候网关8.8.8.8在800端口上收到从server22.2.2.2:2222发来的数据，根据是否转发给192.168.0.3:100可分类几种NAT。 无条件转发给192.168.0.2:100， 这就是全锥型(Full Cone)NAT。 如果192.168.0.2:100之前给2.2.2.2发送过数据，则转发， 这就是受限锥型(Restricted Cone)。 如果192.168.0.2:100之前给2.2.2.2:2222发送过数据，则转发， 这就是端口受限锥型(Port Restricted Cone)。 丢弃报文，拒绝转发, 这就是对称型NAT。 从上面也描述也可以看出，安全性系数, 对称型 &gt; 端口受限锥型 &gt; 受限锥型 &gt; 全锥型","link":"/2021/03/11/%E5%9F%BA%E7%A1%80/%E5%87%A0%E7%A7%8DNAT%E7%B1%BB%E5%9E%8B/"},{"title":"【基础】mysql 数据库引擎","text":"参考：https://www.cnblogs.com/0201zcr/p/5296843.html 数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。 使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。 ACID事务A 事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚. Innodb引擎Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。 MyIASMMyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。 两种引擎的选择大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候。","link":"/2021/03/28/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/"},{"title":"【每日一题_基础】网络各层常见协议","text":"TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为网络接口层、网络层、传输层和应用层。 网络接口：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。网络层：负责路由以及把分组报文发送给目标网络或主机。传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。应用层：负责向用户提供应用程序，比如HTTP（80、HTTPS-443）、FTP（21控制,20数据）、Telnet(23)、DNS(53 udp)、SMTP（25）、SSH（22）等。 OSI 七层：物理层、链路层、网络层、传输层、会话层、表示层、应用层。 抽象五层：物理层、链路层、网络层、传输层、应用层。","link":"/2021/03/13/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE/"},{"title":"【基础】输入URL到页面发生了什么","text":"更多问法：命令行输入curl URL发生了什么？不带有任何参数时，curl 就是发出 GET 请求。-d用于发送POST请求数据体。 URL 解析搜索功能http 或者 https，强制https安全检查、访问限制等（浏览器特色）检查缓存 DNS 查询浏览器缓存、本地缓存（host）、路由器缓存、DNS服务器（设置的）、根域名服务器（递归查询、迭代查询）DNS劫持，可发生在本机、路由器、DNS服务器DNS Prefetch，默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果。 TCP 连接 应用层：构造HTTP报文，请求报头（Request Header）：请求方法、目标地址、遵循的协议等等 + 请求主体（其他参数）。浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法 传输层：构造TCP报文段 网络层：ARP协议，判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。 链路层：以太网协议每一帧分为两个部分， 标头：数据包的发送者、接受者、数据类型 数据：数据包具体内容 服务器连接监听得到的请求，然后开启一个子进程去处理这个请求。处理请求，对HTTP协议进行解析（请求方法、域名、路径等）验证是否配置虚拟主机，验证虚拟主机是否接受此方法，验证该用户可以使用该方法（根据 IP 地址、身份信息等）。假如服务器配置了 HTTP 重定向，就会返回一个 301永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。 浏览器接收响应首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。如果响应资源进行了压缩（比如 gzip），还需要进行解压。然后，对响应资源做缓存。接下来，根据响应资源里的 MIME 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。 渲染页面HTML解析：解码（encoding）、预解析（pre-parsing）、符号化（Tokenization）、构建树（tree construction）（创建DOM）CSS解析：在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序。渲染树：DOM 树和 CSS 规则树合并的过程。当遇到一个script标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。、布局与绘制、合并渲染层、 回流与重绘 JS编译执行词法分析预编译执行","link":"/2021/03/17/%E5%9F%BA%E7%A1%80/%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD/"},{"title":"【算法】栈和队列的区别","text":"栈和队列都是一种逻辑的结构，具体实现用链表和数组都可以。 栈的特点是先进后出，栈的数据访问很严格，只能访问最后加入的数据，这对数据访问控制严格的应用很有好处。应用中，如字符串倒序输出，运算符的匹配，使用栈的原理就可以很好的实现。程序函数的调用就是使用的栈，完成函数后返回到栈顶指针执行。 队列的特点是先进先出，数据从队列尾插入，从队列头读取，可以模拟很多现实的生产环境，例如排队，不允许有任何元素插队，常用于生产消费模型，队列有产品，通知消费者来消费，无产品通知生产者生产。","link":"/2021/03/06/%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"categories":[{"name":"生产","slug":"生产","link":"/categories/%E7%94%9F%E4%BA%A7/"},{"name":"招聘","slug":"招聘","link":"/categories/%E6%8B%9B%E8%81%98/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"基础","slug":"基础","link":"/categories/%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}