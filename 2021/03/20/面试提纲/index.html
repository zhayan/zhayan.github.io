<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>面试提纲 - YanBlog</title><meta name="robots" content="noindex"><meta description="自我介绍"><meta property="og:type" content="blog"><meta property="og:title" content="面试提纲"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="YanBlog"><meta property="og:description" content="自我介绍"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-03-20T13:36:07.000Z"><meta property="article:modified_time" content="2021-04-01T01:49:35.327Z"><meta property="article:author" content="ZhaYan"><meta property="article:tag" content="面试"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://yoursite.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2021/03/20/%E9%9D%A2%E8%AF%95%E6%8F%90%E7%BA%B2/"},"headline":"YanBlog","image":["http://yoursite.com/img/og_image.png"],"datePublished":"2021-03-20T13:36:07.000Z","dateModified":"2021-04-01T01:49:35.327Z","author":{"@type":"Person","name":"ZhaYan"},"description":"自我介绍"}</script><link rel="canonical" href="http://yoursite.com/2021/03/20/%E9%9D%A2%E8%AF%95%E6%8F%90%E7%BA%B2/"><link rel="icon" href="/img/icon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="YanBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2021-03-20T13:36:07.000Z" title="2021-03-20T13:36:07.000Z">2021-03-20</time><span class="level-item"><a class="link-muted" href="/categories/%E6%8B%9B%E8%81%98/">招聘</a></span><span class="level-item">1 小时 读完 (大约 12074 个字)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">面试提纲</h1><div class="content"><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><a id="more"></a>
<p>SJTU 硕士<br>网络空间安全<br>数据结构、操作系统、计算机网络<br>项目经历<br>加速器 运行在PC的软件，连接加速服务器，作为网关将局域网的主机游戏的数据包转发到加速服务器，完成加速<br>手势密码 通过录制用户输入图案密码的视频，获取视频中用户手部的运动，还原密码，使用python实现</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="C-是什么？"><a href="#C-是什么？" class="headerlink" title="C++ 是什么？"></a>C++ 是什么？</h3><p>以C语言为基础，开发的一种面向对象的语言<br>支持面向对象编程、泛型编程和过程化编程<br>常用于系统开发，引擎开发等<br>支持类：类、封装、重载等特性</p>
<h3 id="与C语言区别"><a href="#与C语言区别" class="headerlink" title="与C语言区别"></a>与C语言区别</h3><p>C 面向过程 结构化语言 直接访问内存 硬件编程 效率高移植性好<br>C++ 兼容面向过程 面向对象（struct public） 继承多态 泛型编程 STL</p>
<h3 id="extern-关键字"><a href="#extern-关键字" class="headerlink" title="extern 关键字"></a>extern 关键字</h3><p>extern C 链接C库的函数 因为重载，C++会编译翻译成函数名+形参，在C库中找不到<br>extern 在其他模块寻找定义<br>与static对比 static存在静态区，声明时定义， 只在模块中生效， 不与extern连用<br>与const 与extern连用来声明该常量可以作用于其他编译模块中</p>
<h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>局部 变静态，改变存储位置，声明周期同程序<br>全局 函数 不改位置，不能被其他模块链接<br>静态函数 只有一个实例<br>类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。<br>static 成员只能类外初始化<br>可以通过类名访问（无对象生成时亦可），也可以通过对象访问</p>
<h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><p>修饰类的成员变量，表示成员常量，不能被修改。<br>修饰函数 承诺不修改类内数据成员 不调用其他非const<br>使用const构成重载<br>类外定义const成员函数 声明和定义都要const</p>
<h3 id="volitale关键字"><a href="#volitale关键字" class="headerlink" title="volitale关键字"></a>volitale关键字</h3><p>它用来解决变量在共享环境下容易出现读取错误的问题。<br>volitale 是拒绝编译器的优化，直接从内存读取数据的关键字。<br>使用实例：中断程序访问到的变量；多线程多任务共享的变量。</p>
<h3 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h3><p>阻止隐式的类型转换</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的类中<br>封装的意义在于保护或者防止代码（数据）被我们无意中破坏。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承主要实现重用代码，节省开发时间。<br>子类可以继承父类的一些东西。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>函数过程 多种输入 不同结果<br>不同对象 相同输入 不同结果<br>指向基类的指针，来调用实现派生类中的方法。<br>每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。<br>子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等</p>
<h3 id="静态关联与动态关联"><a href="#静态关联与动态关联" class="headerlink" title="静态关联与动态关联"></a>静态关联与动态关联</h3><p>关联：确定调用的具体对象的过程。（指把一个函数名和一个类对象捆绑在一起，建立关联）。<br>静态关联：在编译时即可确定其调用的虚函数属于哪一个类，例如函数重载和通过对象名调用的虚函数。<br>动态关联：编译系统把他放在运行阶段进行处理，在运行阶段确定关联关系。</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>智能指针是一个存储指向动态分配（堆）对象指针的类，构造函数传入普通指针，析构函数释放指针。栈上分配，函数或程序结束自动释放，防止内存泄露。<br>unique_ptr， 独占所指对象，不支持复制和赋值，直接赋值会编译出错。<br>shared_ptr， 允许多个指针指向同个对象，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。<br>weak_ptr, 指向shared_ptr,管理</p>
<p>构造函数中计数初始化为1；<br>拷贝构造函数中计数值加1；<br>赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；<br>析构函数中引用计数减一；<br>在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。<br>share_prt与weak_ptr的区别？</p>
<p>智能指针的循环引用怎么回事？如何解决？<br>两个指针相互指向对方，析构时由于引用计数不为0导致内存泄漏。<br>方法：采用弱引用的weak_ptr即可。弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。<br>智能指针是线程安全的吗？<br>shared_ptr 本身不是 100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>一个派生类有两个或多个基类class D:public A,private B,protected C<br>二义性：基类同名成员（限定符）、基类派生类同名成员（同名覆盖）、多基类继承同基类（看不到爷爷）<br>虚继承，间接基类中的成员只会保留一份</p>
<h3 id="赋值构造和拷贝构造"><a href="#赋值构造和拷贝构造" class="headerlink" title="赋值构造和拷贝构造"></a>赋值构造和拷贝构造</h3><p>一般如果构造函数中存在动态内存分配，则必须定义拷贝构造函数。否则，可能会导致两个对象成员指向同一地址，出现“指针悬挂问题”。</p>
<h3 id="必须在构造函数初始化列表的"><a href="#必须在构造函数初始化列表的" class="headerlink" title="必须在构造函数初始化列表的"></a>必须在构造函数初始化列表的</h3><p>1，常量成员<br>常量成员只能初始化不能赋值，所以必须放在初始化列表里。<br>2，引用类型<br>引用必须在定义时初始化，并且不能重新赋值，所以必须放在初始化表里。<br>3，对象成员</p>
<h3 id="析构函数可以抛出异常吗？"><a href="#析构函数可以抛出异常吗？" class="headerlink" title="析构函数可以抛出异常吗？"></a>析构函数可以抛出异常吗？</h3><p>C++标准指明析构函数不能、也不应该抛出异常。<br>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。<br>通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</p>
<h3 id="不能是虚函数"><a href="#不能是虚函数" class="headerlink" title="不能是虚函数"></a>不能是虚函数</h3><p>普通函数只能重载，不能被重写，因此编译器会在编译时绑定函数。<br>构造函数是知道全部信息才能创建对象，然而虚函数允许只知道部分信息。<br>内联函数在编译时被展开，虚函数在运行时才能动态绑定函数。<br>友元函数 因为不可以被继承。<br>静态成员函数 只有一个实体，不能被继承。父类和子类共有。</p>
<h3 id="C-四种类型转换"><a href="#C-四种类型转换" class="headerlink" title="C++四种类型转换"></a>C++四种类型转换</h3><p> const_cast 转换成非常量<br> static_cast 强制转换，基类和派生类之间指针或引用的转换<br> dynamic_cast与编译器的属性设置有关<br> reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>以结构体最宽的类型倍数</p>
<h3 id="内联与宏"><a href="#内联与宏" class="headerlink" title="内联与宏"></a>内联与宏</h3><p>内联函数是用来消除函数调用时的时间开销。频繁被调用的短小函数非常受益。<br>A. 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。<br>B. 宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结</p>
<p>单例模式 一个类只有一个实例 一个全局访问点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Singleton(<span class="keyword">const</span> <span class="built_in">string</span> value): value_(value)&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton* singleton_;</span><br><span class="line">    <span class="built_in">string</span> value_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singleton(Singleton &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;    <span class="keyword">return</span> value_;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::singleton_= <span class="literal">nullptr</span>;;</span><br><span class="line"><span class="function">Singleton *<span class="title">Singleton::GetInstance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span>(singleton_==<span class="literal">nullptr</span>)&#123;singleton_ = <span class="keyword">new</span> Singleton(value);&#125;</span><br><span class="line">    <span class="keyword">return</span> singleton_;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Product() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;Result of the ConcreteProduct1&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&#123;Result of the ConcreteProduct2&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Creator()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Product* <span class="title">FactoryMethod</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">SomeOperation</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Product* product = <span class="keyword">this</span>-&gt;FactoryMethod();</span><br><span class="line">    <span class="built_in">string</span> result = <span class="string">"Creator: The same creator's code has just worked with "</span> + product-&gt;Operation();</span><br><span class="line">    <span class="keyword">delete</span> product;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator1</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator2</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>容器和算法<br>序列式容器：vector、list、deque、stack、queue、heap、priority_queue<br>关联式容器，内部结构基本上是一颗平衡二叉树：set、map、multiset、multimap<br>set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。</p>
<h3 id="vector中erase-和remove-的区别？"><a href="#vector中erase-和remove-的区别？" class="headerlink" title="vector中erase()和remove()的区别？"></a>vector中erase()和remove()的区别？</h3><p>erase函数可以用于删除vector容器中的一个或者一段元素。在进行单个元素删除后，传入的迭代器指向不变，仍然指向被删除元素的位置。<br>vector中remove的作用是将范围内为val的值都remove到后面，返回新的end()值（非val部分的end）,但传入的原vector的end并没有发生改变，因此size也就没有变化。</p>
<h3 id="RB-tree特点"><a href="#RB-tree特点" class="headerlink" title="RB-tree特点"></a>RB-tree特点</h3><p>每个节点或者是黑色，或者是红色。<br>根节点是黑色。<br>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>如果一个节点是红色的，则它的子节点必须是黑色的。<br>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<h3 id="栈和队列都"><a href="#栈和队列都" class="headerlink" title="栈和队列都"></a>栈和队列都</h3><p>一种逻辑的结构，具体实现用链表和数组都可以。<br>栈的特点是先进后出，栈的数据访问很严格，只能访问最后加入的数据，这对数据访问控制严格的应用很有好处。应用中，如字符串倒序输出，运算符的匹配，使用栈的原理就可以很好的实现。程序函数的调用就是使用的栈，完成函数后返回到栈顶指针执行。<br>队列的特点是先进先出，数据从队列尾插入，从队列头读取，可以模拟很多现实的生产环境，例如排队，不允许有任何元素插队，常用于生产消费模型，队列有产品，通知消费者来消费，无产品通知生产者生产。</p>
<h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><ol>
<li>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；</li>
<li>引用使用时无需解引用(*)，指针需要解引用；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li>
<li>引用没有 const，指针有 const；</li>
<li>引用不能为空，指针可以为空；</li>
<li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</li>
<li>指针和引用的自增(++)运算意义不一样；</li>
<li>指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的）</li>
<li>从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</li>
</ol>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。<br>使用的时候要记得分配的长度。<br>malloc的时候得确定在那里free.<br>对指针赋值的时候应该注意被赋值指针需要不需要释放.<br>动态分配内存的指针最好不要再次赋值.<br>(1)在windows平台下通过CRT中的库函数进行检测；<br>(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置<br>(3)Linux下通过工具valgrind检测</p>
<h3 id="静态动态内存分配"><a href="#静态动态内存分配" class="headerlink" title="静态动态内存分配"></a>静态动态内存分配</h3><p>静态内存分配是在编译时完成的，不占用CPU资源；动态分配内存运行时完成，分配与释放需要占用CPU资源；<br>静态内存分配是在栈上分配的，动态内存是堆上分配的，malloc函数；</p>
<h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><ol>
<li>malloc和free是库函数，而new和delete是C++操作符；</li>
<li>new自己计算需要的空间大小，比如’int * a = new，malloc需要指定大小，例如’int * a = malloc(sizeof(int))’；</li>
<li>new在动态分配内存的时候可以初始化对象，调用其构造函数，delete在释放内存时调用对象的析构函数。而malloc只分配一段给定大小的内存，并返回该内存首地址指针，如果失败，返回NULL。</li>
<li>new是C++操作符，是关键字，而operate new是C++库函数</li>
<li>opeartor new /operator delete可以重载，而malloc不行</li>
<li>new可以调用malloc来实现，但是malloc不能调用new来实现</li>
<li>对于数据C++定义new[]专门进行动态数组分配，用delete[]进行销毁。new[]会一次分配内存，然后多次调用构造函数；delete[]会先多次调用析构函数，然后一次性释放。</li>
<li>malloc能够直观地重新分配内存 realloc</li>
</ol>
<h3 id="delete-数组"><a href="#delete-数组" class="headerlink" title="delete[] 数组"></a>delete[] 数组</h3><p>new的前四个字节存储了数组的长度,对数组对象逐一析构</p>
<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h3><ol>
<li>TCP面向连接， UDP无连接的</li>
<li>TCP有保障的，UDP传输无保障的</li>
<li>TCP是效率低的首部20，UDP效率高首部8</li>
<li>TCP是基于流的，UDP基于数据报文</li>
<li>TCP传输重要数据，UDP传输不重要的数据<br>TCP SMTP TELNET HTTP FTP<br>UDP DNS NFS TFTP</li>
</ol>
<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>等待服务器应答包到达后，再发送下一个数据包。数据在发送端被缓存，如果缓存到达指定大小就将其发送，或者上一个数据的应答包到达，将缓存区一次性全部发送。。</p>
<h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><p>TCP s:socket(family,,protocol) bind(fd,ipport) listen() accept()阻塞 write() read() send() recv() c:socket() connect()阻塞 rw() close()<br>UDP s:socket() bind() sendto() recvfrom() c:socket() sendto() recvfrom()  close() connect()</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>epoll和select的区别？<br>select在一个进程中打开的最大fd是有限制的，由FD_SETSIZE设置，默认值是2048。不过 epoll则没有这个限制，内存越大，fd上限越大，1G内存都能达到大约10w左右。<br>select的轮询机制是系统会去查找每个fd是否数据已准备好，当fd很多的时候，效率当然就直线下降了，epoll采用基于事件的通知方式，一旦某个fd数据就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，高效。<br>select还是epoll都需要内核把FD消息通知给用户空间，epoll是通过内核于用户空间mmap同一块内存实现的，而select则做了不必要的拷贝<br>select底层是数组，poll是链表，epoll是红黑树</p>
<h3 id="epoll的工作模式"><a href="#epoll的工作模式" class="headerlink" title="epoll的工作模式"></a>epoll的工作模式</h3><p>LT(level triggered) 是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。<br>ET (edge-triggered) 是高速工作方式，只支持no-block socket。 在这种模式下，当描述符从未就绪变为就绪时，内核就通过epoll告诉你，然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作而导致那个文件描述符不再是就绪状态。不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</p>
<h3 id="TCP重传"><a href="#TCP重传" class="headerlink" title="TCP重传"></a>TCP重传</h3><p>超时重传（RTO）<br>当一个包被发送后，就开启一个定时器，如果定时时间到了，还未收到能确认该发送包的应答包，就重传一份数据。注意收到的应答包可能是该包也可能是后面包的，但是只要能确认该包被收到就行。另外如果，是因为网络延时造成重传，则接受端收到重复数据包后丢弃该包。<br>快速重传<br>当如果发送端收到一个包的三次应答包后，立即重传，比超时重传更高效。</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>滑动窗口<br>慢启动算法（工作过程如下图所示）：设置初始拥塞窗口大小为1，以后每收到一个应答拥塞窗口大小就加1，窗口大小呈指数级增长。客户端可发送数据的取拥塞窗口和应答包窗口两者中较小的那个。<br>此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。<br>超时后重新慢启动，到阈值线性增加，再超时再设置阈值，快速恢复，窗口是之前超时的一半</p>
<h3 id="坚持定时器"><a href="#坚持定时器" class="headerlink" title="坚持定时器"></a>坚持定时器</h3><p>TCP不对ACK应答报文进行确认，如果接受端缓冲被占满，发送一个窗口为0的应答，过了一段时间数据处理完毕，重新发送一个应答，告诉发送端窗口大小。不幸的是，如果这个包丢了，就会进入死锁状态——发送端等待更新窗口的应答包，接收端等待接收数据。<br>为了避免死锁了发生，TCP使用了一个坚持定时器来周期性地向接收方查询，以便发现窗口是否已经增大。这一过程也被称为窗口探查。</p>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>http数据由请求行，首部字段，空行，报文主体四个部分组成<br>首部字段分为：通用首部字段，请求首部字段，响应首部字段，实体首部字段<br>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它URL.<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p>
<p>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。连接无法复用<br>HTTP 1.1支持持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。<br>HTTP2.0 多路复用 (Multiplexing)同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。<br>服务端推送（Server Push）</p>
<p>GET 请求获取Request-URI所标识的资源<br>POST 在Request-URI所标识的资源后附加新的数据<br>PUT 请求服务器存储一个资源，并用Request-URI作为其标识<br>DELETE 请求服务器删除Request-URI所标识的资源</p>
<p>GET 用于获取信息，是无副作用的，是幂等的，且可缓存<br>POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存</p>
<h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</p>
<h3 id="Cookie的缺陷"><a href="#Cookie的缺陷" class="headerlink" title="Cookie的缺陷"></a>Cookie的缺陷</h3><p>cookie会被附加在每个HTTP请求中，所以无形中增加了流量。<br>由于在HTTP请求中的cookie是明文传递的，所以安全性成问题。(除非用HTTPS)<br>Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。</p>
<h3 id="程序内存"><a href="#程序内存" class="headerlink" title="程序内存"></a>程序内存</h3><p>1.栈 - 由编译器自动分配释放<br>2.堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收<br>3.全局区(静态区)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，<br>未初始化的在相邻的另一块区域。- 程序结束释放<br>4.另外还有一个专门放常量的地方。- 程序结束释放<br>5 程序代码区，存放2进制代码。<br>在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)，在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的”adgfdf”这样的字符串存放在常量区。</p>
<h3 id="Copy-on-write"><a href="#Copy-on-write" class="headerlink" title="Copy-on-write"></a>Copy-on-write</h3><p>如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<h3 id="常用sql"><a href="#常用sql" class="headerlink" title="常用sql"></a>常用sql</h3><p>SELECT * FROM * WHERE/HAVING BETWEEN LIKE IN<br>GROUP BY ORDER BY<br>JOIN INNER JOIN/LEFT OUTER JOIN<br>嵌套查询</p>
<h3 id="三大范式："><a href="#三大范式：" class="headerlink" title="三大范式："></a>三大范式：</h3><p>每一项都是不可分割的原子项<br>非码属性必须完全依赖于候选码，如果不是需要分表<br>非主属性不可依赖于其他非主属性。（不可传递依赖主属性）</p>
<h3 id="b-树相比于b树的查询优势："><a href="#b-树相比于b树的查询优势：" class="headerlink" title="b+树相比于b树的查询优势："></a>b+树相比于b树的查询优势：</h3><p>b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；<br>b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；<br>对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历</p>
<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作。<br>把多条语句作为一个整体进行操作的功能，被称为数据库事务。</p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>A  事务的原子性(Atomicity)：指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.<br>C 事务的一致性(Consistency)：指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b也应该随之改变.<br>I 独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.<br>D 持久性(Durability）:事务的持久性是指事务执行成功以后,该事务所对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.</p>
<h3 id="事务的四个隔离等级和解决的问题。"><a href="#事务的四个隔离等级和解决的问题。" class="headerlink" title="事务的四个隔离等级和解决的问题。"></a>事务的四个隔离等级和解决的问题。</h3><p>读未提交（脏读）读已提交（不可重复读）可重复读（幻读）串行化<br>读提交，就是一个事务要等另一个事务提交后才能读取数据。<br>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。<br>串行化，是最高的事务隔离级别，在该级别下，事务串行化顺序执行。</p>
<h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><p>Innodb 支持事务处理与外键和行级锁。而MyISAM不支持。<br>这种把多条语句作为一个整体进行操作的功能，被称为数据库事务。<br>InnoDB：<br>支持事务处理等<br>不加锁读取<br>支持外键<br>支持行锁<br>不支持FULLTEXT类型的索引<br>不保存表的具体行数，扫描表来计算有多少行<br>DELETE 表时，是一行一行的删除<br>InnoDB 把数据和索引存放在表空间里面<br>跨平台可直接拷贝使用<br>InnoDB中必须包含AUTO_INCREMENT类型字段的索引<br>表格很难被压缩</p>
<p>MyISAM：<br>不支持事务，回滚将造成不完全回滚，不具有原子性<br>不支持外键<br>支持全文搜索<br>保存表的具体行数,不带where时，直接返回保存的行数<br>DELETE 表时，先drop表，然后重建表<br>MyISAM 表被存放在三个文件 。frm 文件存放表格定义。 数据文件是MYD (MYData) 。 索引文件是MYI (MYIndex)引伸<br>跨平台很难直接拷贝<br>MyISAM中可以使AUTO_INCREMENT类型字段建立联合索引<br>表格可以被压缩</p>
<p>选择：<br>因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原子性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。<br>如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB就是首选了。</p>
<h3 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h3><p>聚集索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。<br>非聚集索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p>
<p>唯一索引<br>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p>
<h3 id="为什么使用redis？"><a href="#为什么使用redis？" class="headerlink" title="为什么使用redis？"></a>为什么使用redis？</h3><p>考虑性能和并发。<br>性能上：我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。Redis基于内存级别的缓存。<br>并发上：高并发下优先访问redis数据，避免直接访问数据库<br>支持的数据类型</p>
<p>string，hash（登录存储用户信息），list（消息队列），set，sorted set</p>
<h3 id="redis存在哪些问题"><a href="#redis存在哪些问题" class="headerlink" title="redis存在哪些问题"></a>redis存在哪些问题</h3><p>缓存和数据库双写一致性：先更新数据库，再删缓存。如果项目要去强一致性，则不能使用缓存。<br>缓存雪崩：双缓存；缓存失效时间加上随机值，避免集体雪崩<br>缓存击穿：异步更新；互斥锁；过滤非法key<br>缓存并发竞争：锁；串行控制</p>
<h3 id="单线程redis性能快的原因"><a href="#单线程redis性能快的原因" class="headerlink" title="单线程redis性能快的原因"></a>单线程redis性能快的原因</h3><p>纯内存操作<br>单线程操作，避免了频繁的上下文切换<br>采用了非阻塞I/O多路复用机制</p>
<h3 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h3><p>redis采用的是定期删除+惰性删除策略。<br>为什么不用定时删除策略?<br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key。<br>定期删除+惰性删除是如何工作的呢?<br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</p>
<p>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<p>采用定期删除+惰性删除就没其他问题了么?<br>如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</p>
<h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><p>信号量：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。<br>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>命名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。<br>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br>信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。<br>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p>
<h3 id="多线程和多进程的区别"><a href="#多线程和多进程的区别" class="headerlink" title="多线程和多进程的区别"></a>多线程和多进程的区别</h3><p>进程数据是分开的:共享复杂，需要用IPC，同步简单；多线程共享进程数据：共享简单，同步复杂<br>进程创建销毁、切换复杂，速度慢 ；线程创建销毁、切换简单，速度快<br>进程占用内存多， CPU利用率低；线程占用内存少， CPU利用率高<br>进程间不会相互影响 ；进程一个线程挂掉将导致整个进程挂掉<br>线程所私有的：线程id、寄存器的值、栈、线程的优先级和调度策略、线程的私有数据、信号屏蔽字、errno变量</p>
<p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<h3 id="线程池了解吗"><a href="#线程池了解吗" class="headerlink" title="线程池了解吗"></a>线程池了解吗</h3><p>目的是减少线程创建和销毁的开销，以及减少线程创建的数目<br>提交一个任务到线程池中，线程池的处理流程如下：<br>判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。<br>线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<br>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</p>
<h3 id="多线程同步和互斥"><a href="#多线程同步和互斥" class="headerlink" title="多线程同步和互斥"></a>多线程同步和互斥</h3><p>信号量：对应一个down和up操作，down使信号量减1，up使信号量加1，如果信号量大于0，则down后继续执行，如果down等于0，则down后睡眠，但是并不会将信号量减到负数。down和up都是原子操作<br>互斥量：互斥量是信号量的一种特例，他只有0和1两种状态（解锁和加锁）。<br>关键区域：关键区域与互斥量类似，但是最大的区别在于，关键区域会进行忙等待，而互斥量如果不能解锁会自动让出CPU</p>
<p>Windows平台下<br>关键区域（Critical Section）：关键节不是内核对象，在用户态实现了同一进程中线程的互斥。由于使用时不需要从用户态切换到核心态，所以速度很快（X86系统上约为20个指令周期），但其缺点是不能跨进程同步，同时不能指定阻塞时的等待时间，只能无限等待。<br>互斥体（Mutex）：互斥体实现了和关键节类似的互斥功能，但区别在于：互斥体是内核对象，可以实现跨进程互斥，但需要在用户态和核心态之间切换，速度比关键节慢得多（X86系统上约为600个指令周期），同时可以指定阻塞时的等待时间。<br>事件（Event）：事件也是内核对象，具有“信号态”和“无信号态”两种状态。当某一线程等待一个事件时，如果事件为信号态，将继续执行，如果事件为无信号态，那么线程被阻塞。线程能够指定阻塞时的等待时间。<br>信号量（Semaphore）：信号量是一个资源计数器，当某线程获取某信号量时，信号量计数首先减1，如果计数小于0，那么该线程被阻塞；当某线程释放某信号量时，信号量计数首先加1，如果计数小于或等与0，那么唤醒某被阻塞的线程并执行之。</p>
<p>Linux平台下（加锁）<br>互斥锁<br>读写锁<br>自旋锁<br>屏障</p>
<p>死锁就是几个进程申请资源，出现了循环等待的情况</p>
<p>避免死锁的方法：<br>资源是互斥的 ；不可抢占 ；占有且申请；动态检查系统安全性<br>忽略该问题；检测死锁并恢复；仔细分配资源，动态避免死锁；破坏死锁发生条件，避免死锁</p>
<h3 id="内核信号通知"><a href="#内核信号通知" class="headerlink" title="内核信号通知"></a>内核信号通知</h3><p>内核给进程发送信号，是在进程所在的进程表项的信号域设置对应的信号的位。进程处理信号的时机就是从内核态即将返回用户态的时候。<br>执行用户自定义的信号处理函数的方法很巧妙。把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>操作系统为了管理内存，给每个进程都分配独立的地址空间，对32位的系统而言，这个空间的大小是4GB。这4GB并不是实际的物理内存，实际上并不存在，因此有虚拟内存这一名称。<br>虚拟地址空间被分割成多个大小相同的页面(比如4k为一个页面)，物理地址空间被分割成同样大小的页框<br>会经过MMU将逻辑地址转换为物理地址，之前说的页表就保存在MMU中，操作系统为每个进程都维护一个页表。</p>
<p>内核空间就将物理内存分为三个区：ZONE_DMA，ZONE_NORMAL，ZONE_HIHGEM。<br>低端内存的范围上，逻辑地址与物理地址是线性映射的。对于内核空间896M以上剩余的128M是用来访问高端内存的。这128M里的页面到物理页框随机映射的，和用户空间的映射是一样的。低端内存是自动永久映射的，高端内存可以永久映射也可以零时映射。</p>
<h3 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h3><p>就是将内存分成若干块，然后尽可能以最适合的方式满足程序内存需求的一种内存管理算法，伙伴算法的一大优势是它能够完全避免外部碎片的产生。<br>把所有的空闲页框分组为 11 块链表，每一块链表分别包含大小为1，2，4，8，16，32，64，128，256，512 和 1024 个连续的页框。对1024 个页框的最大请求对应着 4MB 大小的连续RAM 块。每一块的第一个页框的物理地址是该块大小的整数倍。例如，大小为 16个页框的块，其起始地址是 16 * 2^12 （2^12 = 4096，这是一个常规页的大小）的倍数。</p>
<h2 id="萌加速网游加速器"><a href="#萌加速网游加速器" class="headerlink" title="萌加速网游加速器"></a>萌加速网游加速器</h2><p>主要功能</p>
<h3 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h3><p>NDIS，Network Driver Interface Specification，网络协议接口标准。从图中我们可以看到包裹在其中的两个驱动程序，一个是NDIS intermediate driver，NDIS中间层驱动程序，另一个是NDIS minport driver，小端口驱动程序。下面简单介绍一下这<br>两个驱动程序：<br>a) Ndis intermediate driver，NDIS中间层驱动程序，对于上层的protocol driver它充当 minport driver的作用，对于下层的minport driver它充当一个protocol driver的作用，所以在驱动程序 DriverEntry中就注册NDIS_PROTOCOL_CHARACTERISTICS和 NDIS_MINIPORT_CHARACTERISTICS，使用protocol characteristics中NDIS API从 miniport driver那里取得数据包，再用miniport characteristics的NDIS API向上层的 protocol driver发送数据包。Nids intermediate driver最大的优势就是所有miniport driver的数据包都要通过它这里倒手给protocol driver，所以网络防火墙就看上了这块风水宝地。现在很多网络防火墙都使用 NDIS intermediate driver做数据包的过滤和拦截工作，过滤的规则设置到 MPSendPackets，PTReceive，PTReceiveRacket这三个函数。<br>NDIS 6.0之后，filter driver就取代了Ndis intermediate driver，WDK中提供源码。<br>b)   Ndis miniport driver一般是由设备厂商提供的，在DDK中也提供了miniport driver的一个例子 e100bex，支持Intel EtherExpressTM PRO/100+ Ethernet PCI adapter 和 Intel EtherExpressTM PRO/100B PCI adapter两款网络适配器。</p>
<p>ddl import</p>
<h3 id="C-线程安全"><a href="#C-线程安全" class="headerlink" title="C#线程安全"></a>C#线程安全</h3><p>list<br>ConcurrentDictionary<br>new thread(函数) ()=&gt;{} lambad 表达式<br>在主进程中join等待每个线程完成</p>
<h3 id="机器字转换"><a href="#机器字转换" class="headerlink" title="机器字转换"></a>机器字转换</h3><p>大小端 BitConverter.IsLittleEndian</p>
<h3 id="NAT类型"><a href="#NAT类型" class="headerlink" title="NAT类型"></a>NAT类型</h3><p>进程间通信<br>socket</p>
<p>Openvpn原理<br>OpenVPN 基于 OpenSSL 来实现安全，但是却不是传统意义上的 SSLVPN，它只是一个普通的 VPN，工作在 IP 层而不是传输层。<br>IPSec 的隧道模式，它将一个 IP 数据报封装于另一个 IP 数据报中，<br>在OpenVpn中，如果用户访问一个远程的虚拟地址（属于虚拟网卡配用的地址系列，区别于真实地址），则操作系统会通过路由机制将数据包（TUN模式）或数据帧（TAP模式）发送到虚拟网卡上，服务程序接收该数据并进行相应的处理后，通过SOCKET从外网上发送出去，远程服务程序通过SOCKET从外网上接收数据，并进行相应的处理后，发送给虚拟网卡，则应用软件可以接收到，完成了一个单向传输的过程，反之亦然。</p>
<h2 id="尚名校家教服务系统"><a href="#尚名校家教服务系统" class="headerlink" title="尚名校家教服务系统"></a>尚名校家教服务系统</h2><p>业务流程<br>前端开发<br>Vue是一个典型的MVVM框架，模型（Model）只是普通的JavaScript对象，修改它则视图（View）会自动更新。这种设计让状态管理变得非常简单而直观。<br>Observer：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者<br>Compile：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数<br>Watcher：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图<br>ajax</p>
<h2 id="无人机"><a href="#无人机" class="headerlink" title="无人机"></a>无人机</h2><p>socket编程<br>java.net.Socket;<br>// 创建Socket对象 &amp; 指定服务端的IP 及 端口号<br>socket = new Socket(“192.168.1.172”, 8989);<br>// 步骤1：从Socket 获得输出流对象OutputStream<br>// 该对象作用：发送数据<br>outputStream = socket.getOutputStream();<br>// 步骤2：写入需要发送的数据到输出流对象中<br>outputStream.write((mEdit.getText().toString()+”\n”).getBytes(“utf-8”));<br>// 特别注意：数据的结尾加上换行符才可让服务器端的readline()停止阻塞<br>// 步骤3：发送数据到服务端<br>outputStream.flush();</p>
<p>LocationManager.java<br> LocationManager.GPS_PROVIDER;</p>
<p>SensorManager.getOrientation()</p>
<p>IO复用<br>andoird手机端JAVA，麦克风获取，socket，地理位置，手机姿态<br>AudioRecord<br>    更接近底层<br>    能够更加自由灵活地控制，可以得到原始的一帧帧PCM音频数据。</p>
<p>audioRecord = new AudioRecord(AUDIO_SOURCE,// 指定音频来源，这里为麦克风<br>                FREQUENCY, // 16000HZ采样频率<br>                CHANNELCONGIFIGURATION,// 录制通道<br>                AUDIO_SOURCE_BUTTOM,// 录制编码格式<br>                recBufSize);// 录制缓冲区大小 //先修改</p>
<p>MediaRecorder.AudioSource.MIC<br>CAMCORDER</p>
<p>LocationManager.getLastKnowLocation()方法获取当前位置 </p>
<p>tensorflow 应用到andoird 声音识别方法<br>libandroid_tensorflow_inference_java.jar<br>// Load the model from disk.<br>new TensorFlowInferenceInterface(assetManager, modelFilename);<br>inferenceInterface.feed<br>inferenceInterface.run</p>
<h2 id="手势密码"><a href="#手势密码" class="headerlink" title="手势密码"></a>手势密码</h2><p>跟踪算法 CSRT TLD<br>追踪器的作用是跟踪连续帧间的运动，当物体始终可见时跟踪器才会有效。追踪器根据物体在前一帧已知的位置估计在当前帧的位置，这样就会产生一条物体运动的轨迹，从这条轨迹可以为学习模块产生正样本（Tracking-&gt;Learning）。<br>使用作者自己提出的Median-Flow追踪算法。</p>
<p>检测器的作用是估计追踪器的误差，如果误差很大就改正追踪器的结果。检测器对每一帧图像都做全面的扫描，找到与目标物体相似的所有外观的位置，从检测产生的结果中产生正样本和负样本，交给学习模块（Detection-&gt;Learning）。算法从所有正样本中选出一个最可信的位置作为这一帧TLD的输出结果，然后用这个结果更新追踪器的起始位置（Detection-&gt;Tracking）。<br>识别算法YOLO<br>轨迹简化</p>
<!-- flag of hidden posts --></div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.jpg" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatpay.png" alt="微信"></span></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://yoursite.com/2021/03/20/%E9%9D%A2%E8%AF%95%E6%8F%90%E7%BA%B2/';
            this.page.identifier = '2021/03/20/面试提纲/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'gityanblog' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.jpg" alt="EMPTY"></figure><p class="title is-size-4 is-block line-height-inherit">EMPTY</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai，China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/zhayan" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/zhayan"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="微博" href="https://weibo.com/6751165904"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="E-mail" href="mailto:zha.y@qq.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8B%9B%E8%81%98/"><span class="level-start"><span class="level-item">招聘</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%94%9F%E4%BA%A7/"><span class="level-start"><span class="level-item">生产</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#自我介绍"><span class="mr-2">1</span><span>自我介绍</span></a></li><li><a class="is-flex" href="#C"><span class="mr-2">2</span><span>C++</span></a><ul class="menu-list"><li><a class="is-flex" href="#C-是什么？"><span class="mr-2">2.1</span><span>C++ 是什么？</span></a></li><li><a class="is-flex" href="#与C语言区别"><span class="mr-2">2.2</span><span>与C语言区别</span></a></li><li><a class="is-flex" href="#extern-关键字"><span class="mr-2">2.3</span><span>extern 关键字</span></a></li><li><a class="is-flex" href="#static-关键字"><span class="mr-2">2.4</span><span>static 关键字</span></a></li><li><a class="is-flex" href="#const-关键字"><span class="mr-2">2.5</span><span>const 关键字</span></a></li><li><a class="is-flex" href="#volitale关键字"><span class="mr-2">2.6</span><span>volitale关键字</span></a></li><li><a class="is-flex" href="#explicit关键字"><span class="mr-2">2.7</span><span>explicit关键字</span></a></li><li><a class="is-flex" href="#封装"><span class="mr-2">2.8</span><span>封装</span></a></li><li><a class="is-flex" href="#继承"><span class="mr-2">2.9</span><span>继承</span></a></li><li><a class="is-flex" href="#多态"><span class="mr-2">2.10</span><span>多态</span></a></li><li><a class="is-flex" href="#静态关联与动态关联"><span class="mr-2">2.11</span><span>静态关联与动态关联</span></a></li><li><a class="is-flex" href="#智能指针"><span class="mr-2">2.12</span><span>智能指针</span></a></li><li><a class="is-flex" href="#多重继承"><span class="mr-2">2.13</span><span>多重继承</span></a></li><li><a class="is-flex" href="#赋值构造和拷贝构造"><span class="mr-2">2.14</span><span>赋值构造和拷贝构造</span></a></li><li><a class="is-flex" href="#必须在构造函数初始化列表的"><span class="mr-2">2.15</span><span>必须在构造函数初始化列表的</span></a></li><li><a class="is-flex" href="#析构函数可以抛出异常吗？"><span class="mr-2">2.16</span><span>析构函数可以抛出异常吗？</span></a></li><li><a class="is-flex" href="#不能是虚函数"><span class="mr-2">2.17</span><span>不能是虚函数</span></a></li><li><a class="is-flex" href="#C-四种类型转换"><span class="mr-2">2.18</span><span>C++四种类型转换</span></a></li><li><a class="is-flex" href="#内存对齐"><span class="mr-2">2.19</span><span>内存对齐</span></a></li><li><a class="is-flex" href="#内联与宏"><span class="mr-2">2.20</span><span>内联与宏</span></a></li><li><a class="is-flex" href="#设计模式"><span class="mr-2">2.21</span><span>设计模式</span></a></li><li><a class="is-flex" href="#STL"><span class="mr-2">2.22</span><span>STL</span></a></li><li><a class="is-flex" href="#vector中erase-和remove-的区别？"><span class="mr-2">2.23</span><span>vector中erase()和remove()的区别？</span></a></li><li><a class="is-flex" href="#RB-tree特点"><span class="mr-2">2.24</span><span>RB-tree特点</span></a></li><li><a class="is-flex" href="#栈和队列都"><span class="mr-2">2.25</span><span>栈和队列都</span></a></li><li><a class="is-flex" href="#指针和引用"><span class="mr-2">2.26</span><span>指针和引用</span></a></li><li><a class="is-flex" href="#内存泄露"><span class="mr-2">2.27</span><span>内存泄露</span></a></li><li><a class="is-flex" href="#静态动态内存分配"><span class="mr-2">2.28</span><span>静态动态内存分配</span></a></li><li><a class="is-flex" href="#new和malloc的区别"><span class="mr-2">2.29</span><span>new和malloc的区别</span></a></li><li><a class="is-flex" href="#delete-数组"><span class="mr-2">2.30</span><span>delete[] 数组</span></a></li><li><a class="is-flex" href="#TCP-UDP"><span class="mr-2">2.31</span><span>TCP UDP</span></a></li><li><a class="is-flex" href="#Nagle算法"><span class="mr-2">2.32</span><span>Nagle算法</span></a></li><li><a class="is-flex" href="#Socket编程"><span class="mr-2">2.33</span><span>Socket编程</span></a></li><li><a class="is-flex" href="#IO多路复用"><span class="mr-2">2.34</span><span>IO多路复用</span></a></li><li><a class="is-flex" href="#epoll的工作模式"><span class="mr-2">2.35</span><span>epoll的工作模式</span></a></li><li><a class="is-flex" href="#TCP重传"><span class="mr-2">2.36</span><span>TCP重传</span></a></li><li><a class="is-flex" href="#TCP拥塞控制"><span class="mr-2">2.37</span><span>TCP拥塞控制</span></a></li><li><a class="is-flex" href="#坚持定时器"><span class="mr-2">2.38</span><span>坚持定时器</span></a></li><li><a class="is-flex" href="#http"><span class="mr-2">2.39</span><span>http</span></a></li><li><a class="is-flex" href="#https"><span class="mr-2">2.40</span><span>https</span></a></li><li><a class="is-flex" href="#Cookie的缺陷"><span class="mr-2">2.41</span><span>Cookie的缺陷</span></a></li><li><a class="is-flex" href="#程序内存"><span class="mr-2">2.42</span><span>程序内存</span></a></li><li><a class="is-flex" href="#Copy-on-write"><span class="mr-2">2.43</span><span>Copy-on-write</span></a></li><li><a class="is-flex" href="#常用sql"><span class="mr-2">2.44</span><span>常用sql</span></a></li><li><a class="is-flex" href="#三大范式："><span class="mr-2">2.45</span><span>三大范式：</span></a></li><li><a class="is-flex" href="#b-树相比于b树的查询优势："><span class="mr-2">2.46</span><span>b+树相比于b树的查询优势：</span></a></li><li><a class="is-flex" href="#数据库事务"><span class="mr-2">2.47</span><span>数据库事务</span></a></li><li><a class="is-flex" href="#ACID"><span class="mr-2">2.48</span><span>ACID</span></a></li><li><a class="is-flex" href="#事务的四个隔离等级和解决的问题。"><span class="mr-2">2.49</span><span>事务的四个隔离等级和解决的问题。</span></a></li><li><a class="is-flex" href="#数据库引擎"><span class="mr-2">2.50</span><span>数据库引擎</span></a></li><li><a class="is-flex" href="#数据库索引"><span class="mr-2">2.51</span><span>数据库索引</span></a></li><li><a class="is-flex" href="#为什么使用redis？"><span class="mr-2">2.52</span><span>为什么使用redis？</span></a></li><li><a class="is-flex" href="#redis存在哪些问题"><span class="mr-2">2.53</span><span>redis存在哪些问题</span></a></li><li><a class="is-flex" href="#单线程redis性能快的原因"><span class="mr-2">2.54</span><span>单线程redis性能快的原因</span></a></li><li><a class="is-flex" href="#redis的过期策略以及内存淘汰机制"><span class="mr-2">2.55</span><span>redis的过期策略以及内存淘汰机制</span></a></li><li><a class="is-flex" href="#进程间通信方式"><span class="mr-2">2.56</span><span>进程间通信方式</span></a></li><li><a class="is-flex" href="#多线程和多进程的区别"><span class="mr-2">2.57</span><span>多线程和多进程的区别</span></a></li><li><a class="is-flex" href="#线程池了解吗"><span class="mr-2">2.58</span><span>线程池了解吗</span></a></li><li><a class="is-flex" href="#多线程同步和互斥"><span class="mr-2">2.59</span><span>多线程同步和互斥</span></a></li><li><a class="is-flex" href="#内核信号通知"><span class="mr-2">2.60</span><span>内核信号通知</span></a></li><li><a class="is-flex" href="#虚拟内存"><span class="mr-2">2.61</span><span>虚拟内存</span></a></li><li><a class="is-flex" href="#伙伴算法"><span class="mr-2">2.62</span><span>伙伴算法</span></a></li></ul></li><li><a class="is-flex" href="#萌加速网游加速器"><span class="mr-2">3</span><span>萌加速网游加速器</span></a><ul class="menu-list"><li><a class="is-flex" href="#驱动开发"><span class="mr-2">3.1</span><span>驱动开发</span></a></li><li><a class="is-flex" href="#C-线程安全"><span class="mr-2">3.2</span><span>C#线程安全</span></a></li><li><a class="is-flex" href="#机器字转换"><span class="mr-2">3.3</span><span>机器字转换</span></a></li><li><a class="is-flex" href="#NAT类型"><span class="mr-2">3.4</span><span>NAT类型</span></a></li></ul></li><li><a class="is-flex" href="#尚名校家教服务系统"><span class="mr-2">4</span><span>尚名校家教服务系统</span></a></li><li><a class="is-flex" href="#无人机"><span class="mr-2">5</span><span>无人机</span></a></li><li><a class="is-flex" href="#手势密码"><span class="mr-2">6</span><span>手势密码</span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-31T01:21:11.084Z">2021-03-31</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/31/%E7%AE%97%E6%B3%95/%E5%BC%82%E6%88%96%E7%94%A8%E4%BA%8E%E4%BA%A4%E6%8D%A2%E8%AF%81%E6%98%8E/">算法/异或用于交换证明</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-28T11:50:01.000Z">2021-03-28</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/28/%E5%9F%BA%E7%A1%80/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">【基础】TCP三次握手、四次挥手</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-28T11:07:30.000Z">2021-03-28</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/28/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E/">【基础】mysql 数据库引擎</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-19T12:04:07.000Z">2021-03-19</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/19/OS/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">【OS】Linux内存管理</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/OS/">OS</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-03-19T11:48:33.000Z">2021-03-19</time></p><p class="title is-6"><a class="link-muted" href="/2021/03/19/OS/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">【OS】IO多路复用</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/OS/">OS</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag is-grey-lightest">18</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="YanBlog" height="28"></a><p class="size-small"><span>&copy; 2021 ZhaYan</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>